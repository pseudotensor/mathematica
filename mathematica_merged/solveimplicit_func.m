(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* see also solveimplicit_superwrapper.nb *)


AutoGeneratedPackage->Button[Automatic, Inherited, BaseStyle -> "Link", ButtonData -> "paclet:ref/Automatic"]


AutoGeneratedPackage->Button[Automatic, Inherited, Appearance -> Automatic, BaseStyle -> "Link", ButtonData -> "paclet:ref/Automatic", Evaluator -> Automatic, Method -> "Preemptive"]


InitializationCell->True


InitializationCell->True


MyPrint[x_]:=Module[{foo,x0=x},
Write[sout,x0];
Print[x0];
]
(* MyPrint[x_]:=Print[x]; *)





myReP[x_]:=Table[x[[ii,1]]->Re[x[[ii,2]]],{ii,1,Length[x]}]  (*Re[x]; (* to suppress complex part *)*)


myRe[x_]:=Abs[Re[x]];
myIm[x_]:=Abs[Im[x]];


dosolveimplicitwrapper[whichcomputer0_]:=Module[
{foo,whichcomputer=whichcomputer0},

(* CHOOSE WHICH FILE TO LOAD IN *)
(* Jon's physics-179.umd.edu *)
If[whichcomputer==4,
 (* name and number of failures in fail file loaded in *)
(*filenamebase="fails.txt";numfails=36212;*)
(*filenamebase="fails.txt";numfails=1031;*)
(*filenamebase="failshigh100.txt";numfails=100;*)
(*filenamebase="failshigherror100.txt";numfails=100;*)
filenamebase="failshigherror.txt";numfails=548;
(*filenamebase="failsentropy453.txt";numfails=453;*)
(*filenamebase="failsenergy.txt";numfails=141;*)
(*filenamebase="fails1new.txt";numfails=1;*)
(*filenamebase="failscheck3.txt";numfails=3;*)

filenamein=StringJoin[Directory[],"/",filenamebase];
(*filin=ToString[$ScriptCommandLine[[1]]];*)
];
(* Ramesh's computer *)
If[whichcomputer==5,
filenamein="/Users/rameshnarayan/documents/olek/radhydro/inversion/fails.txt";
];
(*OpenRead[filein];*)
(*allfailsin=Import[filein,"Table"];*)
(*filein=StringJoin["/data/jon/harmgit/longdoubleversion/runo","/","fails.txt"];*)
str=OpenRead[filenamein];

(* choose output file name *)
filenameout=StringJoin[filenamein,"_out.txt"];
sout = OpenWrite[filenameout,FormatType->CForm];

(* choose Print stderr/stdout output file name *)
filenamemathout=StringJoin[filenamein,"_math.txt"];
stream=OpenWrite[filenamemathout,FormatType->OutputForm];
$Output={stream};
$Messages={stream};



COUNTFINDROOT=1; (* 1 = show number of iterations, stored in "cc" variable and outputted in math.out *)

(* whichg=1 uses direct gcov  whichg=2 uses alpha - beta splitting for utilde *)
whichg=2;

(* whichvel=1 uses ucon[[i]] and uradcon[[i]] as primitives  whichvel=2 uses utilde version *)
whichvel=2;

 (* 1 = lab-frame times T  ; 2 = Ramesh approximate fluid-frame entropy without flux contribution 3 = nearly completely accurate fluid-frame entropy version 4 = fully fluid frame version *)
whichentropy=1;
 (* 1 = lab-frame for all quantities  2 = fluid-frame for energy terms  3= fluid-frame for energy terms using explicitly analytic source 4 = fully fluid frame version *)
whichmhd=1;

doradonly=0; (* 0 = do mhd or entropy as normal   1 = do radiation only *)
dogammamax=1; (* whether to try gammamax for radiation case *)

 (* 18 = long doubles 14 = doubles *)
(* set Precision of numbers read-in *)
myprec=20;

(* normal working precision and tolerance *)
(* normalwprec=14; normaltolprec=9; badtol=10^(-5);*)
(*normalwprec=15; normaltolprec=12; badtol=10^(-6);*)
normalwprec=30; normaltolprec=12; badtol=10^(-6); (* for just getting accurate solution *)
(*normaltolprec=6;  badtol=10^(-4);*)
(* current harm choice *)
(*normaltolprec=9;  badtol=10^(-2);*)
normaliters=100;

(* tolerance for Ui, UU0, and UU0S *)
(* point is that sometimes want to test if can get solution at harm-like tolerance using mathematica, but other times assume harm can get solution using more accurate method than 9D method, and then just want these to be good solution so only testing cases when G is also present *)
(*Uwprec=normalwprec;*)
(*Utolprec=normaltolprec;*)
Uwprec=20;
Utolprec=14;


(* high working precision and tolerance *)
dohighprec=0; (* whether to attempt high precision, high iteration cases *)
Wwprec=60;
Wtolprec=14;
Witers=1000;
(* Choose Jacobian type: Automatic will choose whatever is optimal. *)
JacobianType=Automatic;
(*JacobianType=Symbolic;*)
(*JacobianType=FiniteDifference;*)
(* default difference order is 1 *)
(*JacobianType={FiniteDifference,"DifferenceOrder"->1};*)


(* read-in data *)
(*numele=134; (* don't change *)*)
(*numele=181; (* don't change *)*)
numele=208; (* don't change *)
Clear[j];

ccUi=0;
ccUiS=0;
ccUU0=0;
ccUU0S=0;
cc0=0;
cc0S=0;
cc0W=0;
cc0WS=0;

ccUimax=0;
ccUiSmax=0;
ccUU0max=0;
ccUU0Smax=0;
cc0max=0;
cc0Smax=0;
cc0Wmax=0;
cc0WSmax=0;

errorUi=0;
errorUiS=0;
errorUU0=0;
errorUU0S=0;
error0=0;
error0S=0;
error0W=0;
error0WS=0;

errorUimax=0;
errorUiSmax=0;
errorUU0max=0;
errorUU0Smax=0;
error0max=0;
error0Smax=0;
error0Wmax=0;
error0WSmax=0;

For[j=1,j<=numfails,j++,
Clear[mylist];
mylist=0*Range[1,numele];
Clear[i];
For[i=1,i<=numele,i++,mylist[[i]]=Read[str,Number];];
(*Print["mylist=",Dimensions[mylist]," ",mylist];*)
dosolveimplicitone[j,mylist];
Print["Done=",j];
];
Close[str];

(* some reports *)
numfailsN=N[numfails];
MyPrint["average cc counts: ",Round[ccUi/numfailsN]," ",Round[ccUiS/numfailsN]," ",Round[ccUU0/numfailsN]," ",Round[ccUU0S/numfailsN]," ",Round[cc0/numfailsN]," ",Round[cc0S/numfailsN]," ",Round[cc0W/numfailsN]," ",Round[cc0WS/numfailsN] ];
MyPrint["ccmax counts: ",Round[ccUimax]," ",Round[ccUiSmax]," ",Round[ccUU0max]," ",Round[ccUU0Smax]," ",Round[cc0max]," ",Round[cc0Smax]," ",Round[cc0Wmax]," ",Round[cc0WSmax] ];

MyPrint["average error counts: ",CForm[errorUi/numfailsN]," ",CForm[errorUiS/numfailsN]," ",CForm[errorUU0/numfailsN]," ",CForm[errorUU0S/numfailsN]," ",CForm[error0/numfailsN]," ",CForm[error0S/numfailsN]," ",CForm[error0W/numfailsN]," ",CForm[error0WS/numfailsN] ];
MyPrint["errormax counts: ",CForm[errorUimax]," ",CForm[errorUiSmax]," ",CForm[errorUU0max]," ",CForm[errorUU0Smax]," ",CForm[error0max]," ",CForm[error0Smax]," ",CForm[error0Wmax]," ",CForm[error0WSmax] ];

Close[sout];
];





dosolveimplicitone[j0_,mylist0_]:=Module[
{myj=j0,mylist=mylist0},
(*filin=ToString[$ScriptCommandLine[[1]]];*)
(*filein="/data/jon/harmgit/longdoubleversion/runtt/test.txt";*)
(*filein=StringJoin[Directory[],"/","test.txt"];*)

(*Print["inside mylist=",Dimensions[mylist]," ",mylist];*)
If[numele==134,
{failtype,myid,failnum,gotfirstnofail,dt,gn11,gn12,gn13,gn14,gn21,gn22,gn23,gn24,gn31,gn32,gn33,gn34,gn41,gn42,gn43,gn44,gv11,gv12,gv13,gv14,gv21,gv22,gv23,gv24,gv31,gv32,gv33,gv34,gv41,gv42,gv43,gv44,pp0,pin0,uu00,uu0,uui0,pp1,pin1,uu01,uu1,uui1,pp2,pin2,uu02,uu2,uui2,pp3,pin3,uu03,uu3,uui3,pp4,pin4,uu04,uu4,uui4,pp5,pin5,uu05,uu5,uui5,pp6,pin6,uu06,uu6,uui6,pp7,pin7,uu07,uu7,uui7,pp8,pin8,uu08,uu8,uui8,pp9,pin9,uu09,uu9,uui9,pp10,pin10,uu010,uu10,uui10,pp11,pin11,uu011,uu11,uui11,pp12,pin12,uu012,uu12,uui12,uradcon0,uradcov0,uradcon1,uradcov1,uradcon2,uradcov2,uradcon3,uradcov3,ucon0,ucov0,ucon1,ucov1,ucon2,ucov2,ucon3,ucov3,uradconi0,uradcovi0,uradconi1,uradcovi1,uradconi2,uradcovi2,uradconi3,uradcovi3,uconi0,ucovi0,uconi1,ucovi1,uconi2,ucovi2,uconi3,ucovi3}=mylist;
];
If[numele==181,
{failtype,myid,failnum,gotfirstnofail,errorabs,iters,dt,nstep,steppart,gamgas,gn11,gn12,gn13,gn14,gn21,gn22,gn23,gn24,gn31,gn32,gn33,gn34,gn41,gn42,gn43,gn44,gv11,gv12,gv13,gv14,gv21,gv22,gv23,gv24,gv31,gv32,gv33,gv34,gv41,gv42,gv43,gv44,pp0,ppfirst0,pb0,pin0,uu00,uu0,uui0,pp1,ppfirst1,pb1,pin1,uu01,uu1,uui1,pp2,ppfirst2,pb2,pin2,uu02,uu2,uui2,pp3,ppfirst3,pb3,pin3,uu03,uu3,uui3,pp4,ppfirst4,pb4,pin4,uu04,uu4,uui4,pp5,ppfirst5,pb5,pin5,uu05,uu5,uui5,pp6,ppfirst6,pb6,pin6,uu06,uu6,uui6,pp7,ppfirst7,pb7,pin7,uu07,uu7,uui7,pp8,ppfirst8,pb8,pin8,uu08,uu8,uui8,pp9,ppfirst9,pb9,pin9,uu09,uu9,uui9,pp10,ppfirst10,pb10,pin10,uu010,uu10,uui10,pp11,ppfirst11,pb11,pin11,uu011,uu11,uui11,pp12,ppfirst12,pb12,pin12,uu012,uu12,uui12,uradcon0,uradcov0,uradcon1,uradcov1,uradcon2,uradcov2,uradcon3,uradcov3,ucon0,ucov0,ucon1,ucov1,ucon2,ucov2,ucon3,ucov3,uradconb0,uradcovb0,uradconb1,uradcovb1,uradconb2,uradcovb2,uradconb3,uradcovb3,uconb0,ucovb0,uconb1,ucovb1,uconb2,ucovb2,uconb3,ucovb3,uradconi0,uradcovi0,uradconi1,uradcovi1,uradconi2,uradcovi2,uradconi3,uradcovi3,uconi0,ucovi0,uconi1,ucovi1,uconi2,ucovi2,uconi3,ucovi3}=mylist;
];
If[numele==208,
{failtype,myid,failnum,gotfirstnofail,eomtype,errorabs,iters,dt,nstep,steppart,gamgas,gn11,gn12,gn13,gn14,gn21,gn22,gn23,gn24,gn31,gn32,gn33,gn34,gn41,gn42,gn43,gn44,gv11,gv12,gv13,gv14,gv21,gv22,gv23,gv24,gv31,gv32,gv33,gv34,gv41,gv42,gv43,gv44,pp0,ppfirst0,pb0,pin0,prtuui0,prtuu00,uu00,uu0,uui0,pp1,ppfirst1,pb1,pin1,prtuui1,prtuu01,uu01,uu1,uui1,pp2,ppfirst2,pb2,pin2,prtuui2,prtuu02,uu02,uu2,uui2,pp3,ppfirst3,pb3,pin3,prtuui3,prtuu03,uu03,uu3,uui3,pp4,ppfirst4,pb4,pin4,prtuui4,prtuu04,uu04,uu4,uui4,pp5,ppfirst5,pb5,pin5,prtuui5,prtuu05,uu05,uu5,uui5,pp6,ppfirst6,pb6,pin6,prtuui6,prtuu06,uu06,uu6,uui6,pp7,ppfirst7,pb7,pin7,prtuui7,prtuu07,uu07,uu7,uui7,pp8,ppfirst8,pb8,pin8,prtuui8,prtuu08,uu08,uu8,uui8,pp9,ppfirst9,pb9,pin9,prtuui9,prtuu09,uu09,uu9,uui9,pp10,ppfirst10,pb10,pin10,prtuui10,prtuu010,uu010,uu10,uui10,pp11,ppfirst11,pb11,pin11,prtuui11,prtuu011,uu011,uu11,uui11,pp12,ppfirst12,pb12,pin12,prtuui12,prtuu012,uu012,uu12,uui12,uradcon0,uradcov0,uradcon1,uradcov1,uradcon2,uradcov2,uradcon3,uradcov3,ucon0,ucov0,ucon1,ucov1,ucon2,ucov2,ucon3,ucov3,uradconb0,uradcovb0,uradconb1,uradcovb1,uradconb2,uradcovb2,uradconb3,uradcovb3,uconb0,ucovb0,uconb1,ucovb1,uconb2,ucovb2,uconb3,ucovb3,uradconi0,uradcovi0,uradconi1,uradcovi1,uradconi2,uradcovi2,uradconi3,uradcovi3,uconi0,ucovi0,uconi1,ucovi1,uconi2,ucovi2,uconi3,ucovi3}=mylist;
(* pp and uradcon0-12 etc. are related *)
(* pb and uradconb0-12 etc. are related *)
(* pin and uradconi0-12 etc. are related *)
];
(*Import[filein,"Table"][[1]];*)

result181={failtype,myid,failnum,gotfirstnofail,errorabs,iters,dt,nstep,steppart,gamgas,gn11,gn12,gn13,gn14,gn21,gn22,gn23,gn24,gn31,gn32,gn33,gn34,gn41,gn42,gn43,gn44,gv11,gv12,gv13,gv14,gv21,gv22,gv23,gv24,gv31,gv32,gv33,gv34,gv41,gv42,gv43,gv44,pp0,ppfirst0,pb0,pin0,uu00,uu0,uui0,pp1,ppfirst1,pb1,pin1,uu01,uu1,uui1,pp2,ppfirst2,pb2,pin2,uu02,uu2,uui2,pp3,ppfirst3,pb3,pin3,uu03,uu3,uui3,pp4,ppfirst4,pb4,pin4,uu04,uu4,uui4,pp5,ppfirst5,pb5,pin5,uu05,uu5,uui5,pp6,ppfirst6,pb6,pin6,uu06,uu6,uui6,pp7,ppfirst7,pb7,pin7,uu07,uu7,uui7,pp8,ppfirst8,pb8,pin8,uu08,uu8,uui8,pp9,ppfirst9,pb9,pin9,uu09,uu9,uui9,pp10,ppfirst10,pb10,pin10,uu010,uu10,uui10,pp11,ppfirst11,pb11,pin11,uu011,uu11,uui11,pp12,ppfirst12,pb12,pin12,uu012,uu12,uui12,uradcon0,uradcov0,uradcon1,uradcov1,uradcon2,uradcov2,uradcon3,uradcov3,ucon0,ucov0,ucon1,ucov1,ucon2,ucov2,ucon3,ucov3,uradconb0,uradcovb0,uradconb1,uradcovb1,uradconb2,uradcovb2,uradconb3,uradcovb3,uconb0,ucovb0,uconb1,ucovb1,uconb2,ucovb2,uconb3,ucovb3,uradconi0,uradcovi0,uradconi1,uradcovi1,uradconi2,uradcovi2,uradconi3,uradcovi3,uconi0,ucovi0,uconi1,ucovi1,uconi2,ucovi2,uconi3,ucovi3};
MyPrint[result181];


rho0=SetPrecision[uu00,myprec];
Tud0=SetPrecision[{uu01,uu02,uu03,uu04},myprec];
Rud0=SetPrecision[{uu08,uu09,uu010,uu011},myprec];
Sc0=SetPrecision[uu012,myprec];

rhouu0i=SetPrecision[uui0,myprec];
Tudi=SetPrecision[{uui1,uui2,uui3,uui4},myprec];
Rudi=SetPrecision[{uui8,uui9,uui10,uui11},myprec];
Sci=SetPrecision[uui12,myprec];

rhopp=SetPrecision[uu0,myprec];
Tudpp=SetPrecision[{uu1,uu2,uu3,uu4},myprec];
Rudpp=SetPrecision[{uu8,uu9,uu10,uu11},myprec];
Scpp=SetPrecision[uu12,myprec];

rhoi=SetPrecision[pp0,myprec];
ui=SetPrecision[pp1,myprec];
uut1i=SetPrecision[pp2,myprec];
uut2i=SetPrecision[pp3,myprec];
uut3i=SetPrecision[pp4,myprec];
Eri=SetPrecision[pp8,myprec];
urut1i=SetPrecision[pp9,myprec];
urut2i=SetPrecision[pp10,myprec];
urut3i=SetPrecision[pp11,myprec];
Si=SetPrecision[pp12,myprec];

uu0i=SetPrecision[ucon0,myprec];
uu1i=SetPrecision[ucon1,myprec];
uu2i=SetPrecision[ucon2,myprec];
uu3i=SetPrecision[ucon3,myprec];
uru0i=SetPrecision[uradcon0,myprec];
uru1i=SetPrecision[uradcon1,myprec];
uru2i=SetPrecision[uradcon2,myprec];
uru3i=SetPrecision[uradcon3,myprec];

rhoii=SetPrecision[pin0,myprec];
uii=SetPrecision[pin1,myprec];
uut1ii=SetPrecision[pin2,myprec];
uut2ii=SetPrecision[pin3,myprec];
uut3ii=SetPrecision[pin4,myprec];
Erii=SetPrecision[pin8,myprec];
urut1ii=SetPrecision[pin9,myprec];
urut2ii=SetPrecision[pin10,myprec];
urut3ii=SetPrecision[pin11,myprec];
Sii=SetPrecision[pin12,myprec];

uu0ii=SetPrecision[uconi0,myprec];
uu1ii=SetPrecision[uconi1,myprec];
uu2ii=SetPrecision[uconi2,myprec];
uu3ii=SetPrecision[uconi3,myprec];
uru0ii=SetPrecision[uradconi0,myprec];
uru1ii=SetPrecision[uradconi1,myprec];
uru2ii=SetPrecision[uradconi2,myprec];
uru3ii=SetPrecision[uradconi3,myprec];

(* prtestUiin *)
rhoprtuui=SetPrecision[prtuui0,myprec];
uprtuui=SetPrecision[prtuui1,myprec];
uut1prtuui=SetPrecision[prtuui2,myprec];
uut2prtuui=SetPrecision[prtuui3,myprec];
uut3prtuui=SetPrecision[prtuui4,myprec];
Erprtuui=SetPrecision[prtuui8,myprec];
urut1prtuui=SetPrecision[prtuui9,myprec];
urut2prtuui=SetPrecision[prtuui10,myprec];
urut3prtuui=SetPrecision[prtuui11,myprec];
Sprtuui=SetPrecision[prtuui12,myprec];

(* prtestUU0 *)
rhoprtuu0=SetPrecision[prtuu00,myprec];
uprtuu0=SetPrecision[prtuu01,myprec];
uut1prtuu0=SetPrecision[prtuu02,myprec];
uut2prtuu0=SetPrecision[prtuu03,myprec];
uut3prtuu0=SetPrecision[prtuu04,myprec];
Erprtuu0=SetPrecision[prtuu08,myprec];
urut1prtuu0=SetPrecision[prtuu09,myprec];
urut2prtuu0=SetPrecision[prtuu010,myprec];
urut3prtuu0=SetPrecision[prtuu011,myprec];
Sprtuu0=SetPrecision[prtuu012,myprec];

gamgas=SetPrecision[gamgas,myprec];

(* We don't check Uiin, Ufin fields because those are staggered positions *)

(* initial field prior to implicit solver step, associated with Uiin *)
Bconi1=SetPrecision[pin5,myprec];
Bconi2=SetPrecision[pin6,myprec];
Bconi3=SetPrecision[pin7,myprec];

(* updated field as correct field for implicit solver to use *)
Bcon1=SetPrecision[pp5,myprec];
Bcon2=SetPrecision[pp6,myprec];
Bcon3=SetPrecision[pp7,myprec];

If[whichvel==1,
Clear[uu1,uu2,uu3,uru1,uru2,uru3];
(* pp that gives uu?i and uru?i can be way off if failure from harm*)
constspp={rho->rhoi,u->ui,uu1->uu1i,uu2->uu2i,uu3->uu3i,Er->Eri,uru1->uru1i,uru2->uru2i,uru3->uru3i,S->Si,whichuconi0->SetPrecision[ucon0,myprec],whichuradconi0->SetPrecision[uradcon0,myprec]};
ICpp={{rho,rhoi},{u,ui},{uu1,uu1i},{uu2,uu2i},{uu3,uu3i},{Er,Eri},{uru1,uru1i},{uru2,uru2i},{uru3,uru3i}};
ICppS={{rho,rhoi},{S,Si},{uu1,uu1i},{uu2,uu2i},{uu3,uu3i},{Er,Eri},{uru1,uru1i},{uru2,uru2i},{uru3,uru3i}};
constspin={rho->rhoii,u->uii,uu1->uu1ii,uu2->uu2ii,uu3->uu3ii,Er->Erii,uru1->uru1ii,uru2->uru2ii,uru3->uru3ii,S->Sii,whichuconi0->SetPrecision[uconi0,myprec],whichuradconi0->SetPrecision[uradconi0,myprec]};
(* no constsprtuui or constsprtuu0 *)
ICpin={{rho,rhoii},{u,uii},{uu1,uu1ii},{uu2,uu2ii},{uu3,uu3ii},{Er,Erii},{uru1,uru1ii},{uru2,uru2ii},{uru3,uru3ii}};
ICpinS={{rho,rhoii},{S,Sii},{uu1,uu1ii},{uu2,uu2ii},{uu3,uu3ii},{Er,Erii},{uru1,uru1ii},{uru2,uru2ii},{uru3,uru3ii}};
ICpinrad={{Er,Erii},{uru1,uru1ii},{uru2,uru2ii},{uru3,uru3ii}};
ICpintest={{rho,0.81294331641668613088},{u,-0.39623582536829021164},{uu1,0.0059983053605683365108},{uu2,-6.050321005028674004*10^(-05)},{uu3,0.0016122825983277623461},{Er,8.4180452807836352799},{uru1,1.8487475475809896162*10^(-07)},{uru2,3.0057769907110685415*10^(-07)},{uru3,0.0020962681965309745859}};
constspintest={rho->0.81294331641668613088,u->-0.39623582536829021164,uu1->0.0059983053605683365108,uu2->-6.050321005028674004*10^(-05),uu3->0.0016122825983277623461,Er->8.4180452807836352799,uru1->1.8487475475809896162*10^(-07),uru2->3.0057769907110685415*10^(-07),uru3->0.0020962681965309745859};
];
If[whichvel==2,
Clear[uut1,uut2,uut3,urut1,urut2,urut3];
constspp={rho->rhoi,u->ui,uut1->uut1i,uut2->uut2i,uut3->uut3i,Er->Eri,urut1->urut1i,urut2->urut2i,urut3->urut3i,S->Si,whichuconi0->SetPrecision[ucon0,myprec],whichuradconi0->SetPrecision[uradcon0,myprec]};
constspin={rho->rhoii,u->uii,uut1->uut1ii,uut2->uut2ii,uut3->uut3ii,Er->Erii,urut1->urut1ii,urut2->urut2ii,urut3->urut3ii,S->Sii,whichuconi0->SetPrecision[uconi0,myprec],whichuradconi0->SetPrecision[uradconi0,myprec]};
constsprtuui={rho->rhoprtuui,u->uprtuui,uut1->uut1prtuui,uut2->uut2prtuui,uut3->uut3prtuui,Er->Erprtuui,urut1->urut1prtuui,urut2->urut2prtuui,urut3->urut3prtuui,S->Sprtuui};
constsprtuu0={rho->rhoprtuu0,u->uprtuu0,uut1->uut1prtuu0,uut2->uut2prtuu0,uut3->uut3prtuu0,Er->Erprtuu0,urut1->urut1prtuu0,urut2->urut2prtuu0,urut3->urut3prtuu0,S->Sprtuu0};
ICpin={{rho,rhoii},{u,uii},{uut1,uut1ii},{uut2,uut2ii},{uut3,uut3ii},{Er,Erii},{urut1,urut1ii},{urut2,urut2ii},{urut3,urut3ii}};
ICpinrad={{Er,Erii},{urut1,urut1ii},{urut2,urut2ii},{urut3,urut3ii}};
];
If[0==1,
consts=constspp;
IC=ICpp;
,
consts=constspin;
IC=ICpin;
];


If[whichg==1,
gcon=SetPrecision[{{gn11,gn12,gn13,gn14},{gn12,gn22,gn23,gn24},{gn13,gn23,gn33,gn34},{gn14,gn24,gn34,gn44}},myprec];
gcov=FullSimplify[Inverse[gcon]];
];
If[whichg==2,
gcon=SetPrecision[{{gn11,gn12,gn13,gn14},{gn12,gn22,gn23,gn24},{gn13,gn23,gn33,gn34},{gn14,gn24,gn34,gn44}},myprec];
gcov0=SetPrecision[{{gv11,gv12,gv13,gv14},{gv12,gv22,gv23,gv24},{gv13,gv23,gv33,gv34},{gv14,gv24,gv34,gv44}},myprec];
gcon0=Inverse[gcov0];
alpha=1/Sqrt[-gcon0[[1,1]]];
etavecdown={-alpha,0,0,0};
betaup={0,alpha^2*gcon[[1,2]],alpha^2*gcon[[1,3]],alpha^2*gcon[[1,4]]};
betadown=betaup.gcov0;
betadown[[1]]=0;
etavecup=(1/alpha)*{1,-betaup[[2]],-betaup[[3]],-betaup[[4]]};
betasq=betaup.betadown;
gcov={{-alpha^2+betasq,betadown[[2]],betadown[[3]],betadown[[4]]},{betadown[[2]],gcov0[[2,2]],gcov0[[2,3]],gcov0[[2,4]]},{betadown[[3]],gcov0[[3,2]],gcov0[[3,3]],gcov0[[3,4]]},{betadown[[4]],gcov0[[4,2]],gcov0[[4,3]],gcov0[[4,4]]}};

(* test *)
testwhichg2=FullSimplify[(gcov-gcov0)//.{gn11->gcon0[[1,1]],gn12->gcon0[[1,2]],gn13->gcon0[[1,3]],gn14->gcon0[[1,4]],gn23->gcon0[[2,3]],gn24->gcon0[[2,4]],gn34->gcon0[[3,4]],gn44->gcon0[[4,4]]}];
Print["testwhichg2=",testwhichg2];
];

If[whichvel==1,
Clear[uu0,uu1,uu2,uu3];
ucon={uu0,uu1,uu2,uu3};
ucov=ucon.gcov;
soluu0=Solve[ucon.ucov==-1,uu0];
soluu0a=soluu0[[1,1,2]];
soluu0b=soluu0[[2,1,2]];
vala=soluu0a//.constspin;
valb=soluu0b//.constspin;
testucon0= whichuconi0//.constspin;
If[Abs[vala -testucon0]<Abs[valb- uconi0],uu0=soluu0a,uu0=soluu0b];
Print["uconi0=",uconi0," uu0=",uu0//.constspin," soluu0a=",soluu0a//.constspin," soluu0b=",soluu0b//.constspin];

Clear[uru0,uru1,uru2,uru3];
uradcon={uru0,uru1,uru2,uru3};
uradcov=uradcon.gcov;
soluru0=Solve[uradcon.uradcov==-1,uru0];
soluru0a=soluru0[[1,1,2]];
soluru0b=soluru0[[2,1,2]];
valra=soluru0a//.constspin;
valrb=soluru0b//.constspin;
testuradcon0= whichuradconi0//.constspin;
If[Abs[valra -testuradcon0]<Abs[valrb - uradconi0],uru0=soluru0a,uru0=soluru0b];
Print["uradconi0=",uradconi0," uru0=",uru0//.constspin," soluru0a=",soluru0a//.constspin," soluru0b=",soluru0b//.constspin];
];

If[whichvel==2,
Clear[uu0,uu1,uu2,uu3];
utilde={0,uut1,uut2,uut3};
utildedown=utilde.gcov;
qsq=utilde.utildedown;
gamma=Sqrt[1+qsq];
uu0=gamma/alpha;
ucon=utilde+gamma*etavecup;
ucov=utildedown+gamma*etavecdown;
(* test *)
testuu=FullSimplify[ucon.ucov];
Print["1testuu=",testuu];

Clear[uru0,uru1,uru2,uru3];
urtilde={0,urut1,urut2,urut3};
urtildedown=gcov.urtilde;
qsqr=urtilde.urtildedown;
gammar=Sqrt[1+qsqr];
uru0=gammar/alpha;
urcon=urtilde+gammar*etavecup;
uradcon=urcon;
urcov=urtildedown+gammar*etavecdown;
uradcov=urcov;
(* test *)
testuu=FullSimplify[urcon.urcov];
Print["2testuu=",testuu];
];

Bcon={0,Bcon1,Bcon2,Bcon3};
udotB=Sum[ucov[[ii]]*Bcon[[ii]],{ii,1,4}];
bcon=(1/ucon[[1]])*Table[Bcon[[ii]]+udotB*ucon[[ii]],{ii,1,4}];
bcov=bcon.gcov;
bsq=bcon.bcov;
Pb=bsq/2;

Bconi={0,Bconi1,Bconi2,Bconi3};
udotBi=Sum[ucov[[ii]]*Bconi[[ii]],{ii,1,4}];
bconi=(1/ucon[[1]])*Table[Bconi[[ii]]+udotBi*ucon[[ii]],{ii,1,4}];
bcovi=bconi.gcov;
bsqi=bconi.bcovi;
Pbi=bsqi/2;

arad=118316261947818976;
gam=gamgas;
indexn=1/(gam-1);
P=(gam-1)*u;
T=P/rho;
B=arad*T^4/(4*Pi);
KAPPAES=1;
KAPPA=1;
KAPPAESCODE=590799;
KAPPAFFCODE=3.46764*10^(-17);
kappa=rho*KAPPA*KAPPAFFCODE*rho*T^(-7/2);
kappaes=rho*KAPPAES*KAPPAESCODE;
(*
kappa=rho*KAPPAESCODE/10^(14)*1;
*)
lambda=kappa*4*Pi*B;
chi=kappa+kappaes;

(* entropy*)
S=rho*Log[P^indexn/rho^(indexn+1)];
Sc=S*ucon[[1]];

rhou=Table[rho*ucon[[ii]],{ii,1,4}];
(* rho*ucon[[ii]]*KroneckerDelta[jj,1]*KroneckerDelta[ii,1]+*)
Tud=Table[rho*ucon[[ii]]*KroneckerDelta[jj,1]*KroneckerDelta[ii,1]+(rho+u+P+bsq)*ucon[[ii]]*ucov[[jj]]+KroneckerDelta[ii,jj]*(P+Pb)-bcon[[ii]]*bcov[[jj]],{ii,1,4},{jj,1,4}];
TudBi=Table[rho*ucon[[ii]]*KroneckerDelta[jj,1]*KroneckerDelta[ii,1]+(rho+u+P+bsqi)*ucon[[ii]]*ucov[[jj]]+KroneckerDelta[ii,jj]*(P+Pbi)-bconi[[ii]]*bcovi[[jj]],{ii,1,4},{jj,1,4}];
Rud=Table[(4/3)*Er*uradcon[[ii]]*uradcov[[jj]]+KroneckerDelta[ii,jj]*(Er/3),{ii,1,4},{jj,1,4}];

Ruu=Sum[Rud[[ii,jj]]*ucov[[ii]]*ucon[[jj]],{ii,1,4},{jj,1,4}];
Ru=Table[Sum[Rud[[ii,jj]]*ucon[[jj]],{jj,1,4}],{ii,1,4}];
Gu=Table[-(kappa*Ru[[ii]]+lambda*ucon[[ii]])-kappaes*(Ru[[ii]]+Ruu*ucon[[ii]]),{ii,1,4}];
Gd=Table[Sum[Gu[[ii]]*gcov[[ii,jj]],{ii,1,4}],{jj,1,4}];
GS=(1/T)*(-Gu.ucov);

he=(rho+u+P)/rho;
alpha=Sqrt[-1/gcon[[1,1]]];
DD=alpha*rhou[[1]];
etacov={-alpha,0,0,0};
gamma=-etacov.ucon;
W=DD*he*gamma;
Wp=W-DD;

pinlist={rho,u,uut1,uut2,uut3,Bconi[[1]],Bconi[[2]],Bconi[[3]],Er,urut1,urut2,urut3}//.constspin;
pplist={rho,u,uut1,uut2,uut3,Bconi[[1]],Bconi[[2]],Bconi[[3]],Er,urut1,urut2,urut3}//.constspp;
FullOutput={
"myj",j,
"harmerrorabs",errorabs,
"harmiters=",iters,
"pi (rho,u,uut1,uut2,uut3,B1,B2,B3,Er,urut1,urut2,urut3)",pinlist,
"pp (rho,u,uut1,uut2,uut3,B1,B2,B3,Er,urut1,urut2,urut3)",pplist,
"ucon",ucon//.consts,
"uradcon",uradcon//.consts,
"UUi(rho,T,R,S)",rhouu0i,Tudi,Rudi,Sci,
"UUitest(rho,T,R,S)",rhou[[1]]//.consts,TudBi[[1]]//.consts,Rud[[1]]//.consts,Sc//.consts,
"UUitestdiff(rho,T,R,S)",(rhou[[1]]//.consts)-rhouu0i, (Rud[[1]]//.consts)-Rudi,(TudBi[[1]]//.consts)-Tudi,(Sc//.consts)-Sci,
"UU0(rho,T,R,S)",rho0,Tud0,Rud0,Sc0,
"UUpp(rho,T,R,S)",rhopp,Tudpp,Rudpp,Scpp
};
FullOutput=Flatten[FullOutput];
numFullOutput=Length[FullOutput];
Do[Write[sout,FullOutput[[ii]]],{ii,1,numFullOutput}];



(* Just Ui only to check pi (Ui) from harm *)
If[doradonly==0,
dtcold=0;
ferr0=rhou[[1]]-rhouu0i;
ferr1=Table[(Rud[[1,ii]]-Rudi[[ii]])+dtcold*Gd[[ii]],{ii,1,4}];
ferr2=Table[(TudBi[[1,ii]]-Tudi[[ii]])-dtcold*Gd[[ii]],{ii,1,4}];
chooseresult=constspin;

ferrnorm0=Abs[rhou[[1]]]+Abs[rhouu0i];
ferrnorm1t=Table[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rudi[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,1,1}];
ferrnorm1s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rudi[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,2,4}];
ferrnorm1={ferrnorm1t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm1s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm1s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm1s/Sqrt[Abs[gcon[[4,4]]]]};
ferrnorm2t=Table[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[TudBi[[1,ii]]]+Abs[Tudi[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,1,1}];
ferrnorm2s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[TudBi[[1,ii]]]+Abs[Tudi[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,2,4}];
ferrnorm2={ferrnorm2t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm2s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm2s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm2s/Sqrt[Abs[gcon[[4,4]]]]};
ferr0=(ferr0/ferrnorm0)//.chooseresult;
ferr1=(ferr1/ferrnorm1)//.chooseresult;
ferr2=(ferr2/ferrnorm2)//.chooseresult;

(*chooseresult=constspintest;*)
Print["Aresult=",chooseresult];
Print["AprtestUiin=",constsprtuui];
Print["AprtestUU0=",constsprtuu0];
Print["Pbi=",Pbi//.chooseresult];
ferrtotal=Join[{ferr0},ferr1,ferr2];
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["Aferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
complexprims=myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
If[complexprims==1,MyPrint["Acomplexprims"];];
If[ferrabs==0 &&ferrabsim==0|| ferrabs<badtol && ferrabsim<badtol&&complexprims==False,resulttype1="Good",resulttype1="Bad"];
(* Using badtol because apparently harm doesn't have inversion solution any more accurate than this even for ldouble *)
ccA=0;
If[Re[(u//.chooseresult)]<=0,MyPrint["Aresultnegu"];];
If[Re[(rho//.chooseresult)]<=0,MyPrint["Aresultnegrho"];];
If[Re[(Er//.chooseresult)]<=0,MyPrint["AresultnegEr"];];
If[myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol,MyPrint["Aresultcomplexu"];];
If[myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol,MyPrint["Aresultcomplexrho"];];
If[myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol,MyPrint["AresultcomplexEr"];];
Print["A",resulttype1," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " ccA=",ccA];
Print["AUUi ",rhouu0i," ",Rudi," ",Tudi, " ", Sci];
Print["AUU ",rhou[[1]]//.chooseresult, " ",Rud[[1]]//.chooseresult," ",TudBi[[1]]//.chooseresult," ",Sc//.chooseresult];
Print["AW and W' ",W//.chooseresult," ",Wp//.chooseresult];
Print["Aucon=",ucon//.chooseresult];
Print["Auradcon=",uradcon//.chooseresult];
Print["Agcov=",gcov," gcon=",gcon];

ochooseresult=myReP[chooseresult];
Aplist={rho,u,uut1,uut2,uut3,Bconi[[1]],Bconi[[2]],Bconi[[3]],Er,urut1,urut2,urut3}//.ochooseresult;
FullOutput={
"Awhich(myj,failtype,myid,failnum)",myj,failtype,myid,failnum,
"Aresulttype",resulttype1,
"Aerrorabs",ferrabs+ferrabsim,
"Aiters=",ccA,
"Ap",Aplist,
"Aucon",ucon//.ochooseresult,
"Auradcon",uradcon//.ochooseresult,
"AUU",rhou[[1]]//.ochooseresult,TudBi[[1]]//.ochooseresult,Rud[[1]]//.ochooseresult,Re[Sc]//.ochooseresult
};
FullOutput=Flatten[FullOutput];
numFullOutput=Length[FullOutput];
Do[Write[sout,FullOutput[[ii]]],{ii,1,numFullOutput}];

];
(* get inversion of Ui for entropy (i.e. no source term) *)
If[doradonly==0,
ferr0=rhou[[1]]-rhouu0i;
dtcold=0;
ferr1=Table[(Rud[[1,ii]]-Rudi[[ii]])+dtcold*Gd[[ii]],{ii,1,4}];
ferr2=Table[(TudBi[[1,ii]]-Tudi[[ii]])-dtcold*Gd[[ii]],{ii,1,4}];
(* entropy error function still function of u, not changing independent variable to S or anything like that *)
ferr2[[1]]=T*(Sc-Sci -dtcold*GS); (* lab-frame version *)

chooseresult=constspin;
Print["ASresult=",chooseresult];
Print["Pbi=",Pbi//.chooseresult];

ferrnorm0=Abs[rhou[[1]]]+Abs[rhouu0i];
ferrnorm1t=Table[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rudi[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,1,1}];
ferrnorm1s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rudi[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,2,4}];
ferrnorm1={ferrnorm1t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm1s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm1s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm1s/Sqrt[Abs[gcon[[4,4]]]]};
ferrnorm2t=(Abs[T]*(Abs[Sc]+Abs[Sci]+Abs[dtcold*GS]));
ferrnorm2s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[TudBi[[1,ii]]]+Abs[Tudi[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,2,4}];
ferrnorm2={ferrnorm2t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm2s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm2s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm2s/Sqrt[Abs[gcon[[4,4]]]]};
ferr0=(ferr0/ferrnorm0)//.chooseresult;
ferr1=(ferr1/ferrnorm1)//.chooseresult;
ferr2=(ferr2/ferrnorm2)//.chooseresult;

ferrtotal=Join[{ferr0},ferr1,ferr2];
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["ASferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
complexprims=myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
If[complexprims==1,MyPrint["AScomplexprims"];];
If[ferrabs==0 && ferrabsim==0 || ferrabs<badtol && ferrabsim<badtol&&complexprims==False,resulttype4SnoG="Good",resulttype4SnoG="Bad"];
cc=0;
Print["AS",resulttype4SnoG," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " cc=",cc];
chooseresultUU0noG=chooseresult;
Print["AUUSi ",rhouu0i," ",Rudi," ",Tudi, " ", Sci];
Print["AUUS ",rhou[[1]]//.chooseresult, " ",Rud[[1]]//.chooseresult," ",TudBi[[1]]//.chooseresult," ",Sc//.chooseresult];
If[Re[(u//.chooseresult)]<=0,MyPrint["ASresultnegu"];];
If[Re[(rho//.chooseresult)]<=0,MyPrint["ASresultnegrho"];];
If[Re[(Er//.chooseresult)]<=0,MyPrint["ASresultnegEr"];];
If[myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol,MyPrint["ASresultcomplexu"];];
If[myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol,MyPrint["ASresultcomplexrho"];];
If[myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol,MyPrint["ASresultcomplexEr"];];

ochooseresult=myReP[chooseresult];
ASplist={rho,u,uut1,uut2,uut3,Bconi[[1]],Bconi[[2]],Bconi[[3]],Er,urut1,urut2,urut3}//.ochooseresult;
FullOutput={
"ASwhich(myj,failtype,myid,failnum)",myj,failtype,myid,failnum,
"ASresulttype",resulttype4SnoG,
"ASerrorabs",ferrabs+ferrabsim,
"ASiters=",cc,
"ASp",ASplist,
"ASucon",ucon//.ochooseresult,
"ASuradcon",uradcon//.ochooseresult,
"ASUU",rhou[[1]]//.ochooseresult,TudBi[[1]]//.ochooseresult,Rud[[1]]//.ochooseresult,Re[Sc]//.ochooseresult
};
FullOutput=Flatten[FullOutput];
numFullOutput=Length[FullOutput];
Do[Write[sout,FullOutput[[ii]]],{ii,1,numFullOutput}];

];

If[doradonly==1,
ferr1=Table[(Rud[[1,ii]]-Rudi[[ii]]),{ii,1,4}];
chooseresult=constspin;
(*chooseresult=constspintest;*)
Print["ARADresult=",chooseresult];
ferr1=(ferr1/Max[Er,Er])//.chooseresult;
ferrtotal=ferr1;
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["ARADferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
complexprims=myRe[((u//.chooseresult))]<myIm[((u//.chooseresult))]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
If[complexprims==1,MyPrint["ARADcomplexprims"];];
If[ferrabs==0 && ferrabsim==0 || ferrabs<badtol && ferrabsim<badtol&&complexprims==False,resulttype2="Good",resulttype2="Bad"];
(* Using badtol because apparently harm doesn't have inversion solution any more accurate than this even for ldouble *)
ccARAD=0;
Print["ARAD",resulttype2," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " ccARAD=",ccARAD];
Print["ARADUU ",Rud[[1]]//.chooseresult];
];

(* Just Ui corresponding to the "initial" contribution *)
If[doradonly==0,
dtcold=0;
ferr0=rhou[[1]]-rhouu0i;
ferr1=Table[(Rud[[1,ii]]-Rudi[[ii]])+dtcold*Gd[[ii]],{ii,1,4}];
ferr2=Table[(TudBi[[1,ii]]-Tudi[[ii]])-dtcold*Gd[[ii]],{ii,1,4}];
eqns={ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[2]]==0,ferr2[[3]]==0,ferr2[[4]]==0};
Print["1FindRoot"];
(*myIC=ICpintest;*)
 myIC=ICpin; 
resultorig=Block[{cc=0},{FindRoot[eqns,myIC,WorkingPrecision->Uwprec,MaxIterations->normaliters,AccuracyGoal->Utolprec,PrecisionGoal->Utolprec, Jacobian->JacobianType, StepMonitor:>cc++],cc}];
result=resultorig[[1]];cc=resultorig[[2]];
chooseresult=result;
Print["1result=",chooseresult];
Print["Pbi=",Pbi//.chooseresult];

ferrnorm0=Abs[rhou[[1]]]+Abs[rhouu0i];
ferrnorm1t=Table[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rudi[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,1,1}];
ferrnorm1s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rudi[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,2,4}];
ferrnorm1={ferrnorm1t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm1s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm1s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm1s/Sqrt[Abs[gcon[[4,4]]]]};
ferrnorm2t=Table[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[TudBi[[1,ii]]]+Abs[Tudi[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,1,1}];
ferrnorm2s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[TudBi[[1,ii]]]+Abs[Tudi[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,2,4}];
ferrnorm2={ferrnorm2t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm2s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm2s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm2s/Sqrt[Abs[gcon[[4,4]]]]};
ferr0=(ferr0/ferrnorm0)//.chooseresult;
ferr1=(ferr1/ferrnorm1)//.chooseresult;
ferr2=(ferr2/ferrnorm2)//.chooseresult;

ferrtotal=Join[{ferr0},ferr1,ferr2];
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["1ferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
complexprims=myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
If[complexprims==1,MyPrint["1complexprims"];];
If[ferrabs==0 && ferrabsim==0 || ferrabs<badtol&& ferrabsim<badtol&&complexprims==False,resulttype10="Good",resulttype10="Bad"];
Print["1",resulttype10," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " cc=",cc];
Print["1UUi ",rhouu0i," ",Rudi," ",Tudi, " ", Sci];
Print["1UU ",rhou[[1]]//.chooseresult, " ",Rud[[1]]//.chooseresult," ",TudBi[[1]]//.chooseresult," ",Sc//.chooseresult];
Print["1W and W' ",W//.chooseresult," ",Wp//.chooseresult];
chooseresultUi=chooseresult;
ccUi=ccUi+cc;
ccUimax=Max[ccUimax,cc];
errorUi=errorUi+ferrabs+ferrabsim;
errorUimax=Max[errorUimax,ferrabs+ferrabsim];
If[Re[(u//.chooseresult)]<=0,MyPrint["1resultnegu"];];
If[Re[(rho//.chooseresult)]<=0,MyPrint["1resultnegrho"];];
If[Re[(Er//.chooseresult)]<=0,MyPrint["1resultnegEr"];];
If[myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol,MyPrint["1resultcomplexu"];];
If[myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol,MyPrint["1resultcomplexrho"];];
If[myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol,MyPrint["1resultcomplexEr"];];

ochooseresult=myReP[chooseresult];
p1plist={rho,u,uut1,uut2,uut3,Bconi[[1]],Bconi[[2]],Bconi[[3]],Er,urut1,urut2,urut3}//.ochooseresult;
FullOutput={
"1which(myj,failtype,myid,failnum)",myj,failtype,myid,failnum,
"1resulttype",resulttype10,
"1errorabs",ferrabs+ferrabsim,
"1iters=",cc,
"1p",p1plist,
"1ucon",ucon//.ochooseresult,
"1uradcon",uradcon//.ochooseresult,
"1UU",rhou[[1]]//.ochooseresult,TudBi[[1]]//.ochooseresult,Rud[[1]]//.ochooseresult,Re[Sc]//.ochooseresult
};
FullOutput=Flatten[FullOutput];
numFullOutput=Length[FullOutput];
Do[Write[sout,FullOutput[[ii]]],{ii,1,numFullOutput}];


(* get inversion of Ui for entropy (i.e. no source term) *)
If[doradonly==0,
ferr0=rhou[[1]]-rhouu0i;
dtcold=0;
ferr1=Table[(Rud[[1,ii]]-Rudi[[ii]])+dtcold*Gd[[ii]],{ii,1,4}];
ferr2=Table[(TudBi[[1,ii]]-Tudi[[ii]])-dtcold*Gd[[ii]],{ii,1,4}];
(* entropy error function still function of u, not changing independent variable to S or anything like that *)
ferr2[[1]]=T*(Sc-Sci -dtcold*GS); (* lab-frame version *)

Print["1SFindRoot"];
(*DampingFactor->2,*)
resultorig=Block[{cc=0},{FindRoot[{ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[2]]==0,ferr2[[3]]==0,ferr2[[4]]==0},ICpin,WorkingPrecision->Uwprec,MaxIterations->normaliters,AccuracyGoal->Utolprec,PrecisionGoal->Utolprec, Jacobian->JacobianType,StepMonitor:>cc++],cc}];result=resultorig[[1]];cc=resultorig[[2]];
chooseresult=result;
Print["1Sresult=",chooseresult];
Print["Pbi=",Pbi//.chooseresult];

ferrnorm0=Abs[rhou[[1]]]+Abs[rhouu0i];
ferrnorm1t=Table[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rudi[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,1,1}];
ferrnorm1s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rudi[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,2,4}];
ferrnorm1={ferrnorm1t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm1s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm1s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm1s/Sqrt[Abs[gcon[[4,4]]]]};
ferrnorm2t=(Abs[T]*(Abs[Sc]+Abs[Sci]+Abs[dtcold*GS]));
ferrnorm2s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[TudBi[[1,ii]]]+Abs[Tudi[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,2,4}];
ferrnorm2={ferrnorm2t[[1]],ferrnorm2s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm2s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm2s/Sqrt[Abs[gcon[[4,4]]]]};
ferr0=(ferr0/ferrnorm0)//.chooseresult;
ferr1=(ferr1/ferrnorm1)//.chooseresult;
ferr2=(ferr2/ferrnorm2)//.chooseresult;

ferrtotal=Join[{ferr0},ferr1,ferr2];
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["1Sferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
complexprims=myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
If[complexprims==1,MyPrint["AScomplexprims"];];
If[ferrabs==0 && ferrabsim==0 || ferrabs<badtol && ferrabsim<badtol&&complexprims==False,resulttype4SnoG="Good",resulttype4SnoG="Bad"];
Print["1S",resulttype4SnoG," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " cc=",cc];
Print["1SUUi ",rhouu0i," ",Rudi," ",Tudi, " ", Sci];
Print["1SUU ",rhou[[1]]//.chooseresult, " ",Rud[[1]]//.chooseresult," ",TudBi[[1]]//.chooseresult," ",Sc//.chooseresult];
chooseresultUU0noG=chooseresult;
ccUiS=ccUiS+cc;
ccUiSmax=Max[ccUiSmax,cc];
errorUiS=errorUiS+ferrabs+ferrabsim;
errorUiSmax=Max[errorUiSmax,ferrabs+ferrabsim];
If[Re[(u//.chooseresult)]<=0,MyPrint["1Sresultnegu"];];
If[Re[(rho//.chooseresult)]<=0,MyPrint["1Sresultnegrho"];];
If[Re[(Er//.chooseresult)]<=0,MyPrint["1SresultnegEr"];];
If[myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol,MyPrint["1Sresultcomplexu"];];
If[myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol,MyPrint["1Sresultcomplexrho"];];
If[myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol,MyPrint["1SresultcomplexEr"];];

ochooseresult=myReP[chooseresult];
p1Splist={rho,u,uut1,uut2,uut3,Bconi[[1]],Bconi[[2]],Bconi[[3]],Er,urut1,urut2,urut3}//.ochooseresult;
FullOutput={
"1Swhich(myj,failtype,myid,failnum)",myj,failtype,myid,failnum,
"1Sresulttype",resulttype4SnoG,
"1Serrorabs",ferrabs+ferrabsim,
"1Siters=",cc,
"1Sp",p1Splist,
"1Sucon",ucon//.ochooseresult,
"1Suradcon",uradcon//.ochooseresult,
"1SUU",rhou[[1]]//.ochooseresult,TudBi[[1]]//.ochooseresult,Rud[[1]]//.ochooseresult,Re[Sc]//.ochooseresult
};
FullOutput=Flatten[FullOutput];
numFullOutput=Length[FullOutput];
Do[Write[sout,FullOutput[[ii]]],{ii,1,numFullOutput}];

];


(* Just UU0 corresponding to "initial+flux" contribution *)
dtcold=0;
ferr0=rhou[[1]]-rho0;
ferr1=Table[(Rud[[1,ii]]-Rud0[[ii]])+dtcold*Gd[[ii]],{ii,1,4}];
ferr2=Table[(Tud[[1,ii]]-Tud0[[ii]])-dtcold*Gd[[ii]],{ii,1,4}];
eqns={ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[2]]==0,ferr2[[3]]==0,ferr2[[4]]==0};
Print["2FindRoot"];
resultorig=Block[{cc=0},{FindRoot[eqns,ICpin,WorkingPrecision->Uwprec,MaxIterations->normaliters,AccuracyGoal->Utolprec,PrecisionGoal->Utolprec, Jacobian->JacobianType, StepMonitor:>cc++],cc}];
result=resultorig[[1]];cc=resultorig[[2]];
chooseresult=result;
Print["2result=",chooseresult];
Print["Pb=",Pb//.chooseresult];

ferrnorm0=Abs[rhou[[1]]]+Abs[rho0];
ferrnorm1t=Table[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rud0[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,1,1}];
ferrnorm1s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rud0[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,2,4}];
ferrnorm1={ferrnorm1t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm1s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm1s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm1s/Sqrt[Abs[gcon[[4,4]]]]};
ferrnorm2t=Table[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Tud[[1,ii]]]+Abs[Tud0[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,1,1}];
ferrnorm2s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Tud[[1,ii]]]+Abs[Tud0[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,2,4}];
ferrnorm2={ferrnorm2t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm2s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm2s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm2s/Sqrt[Abs[gcon[[4,4]]]]};
ferr0=(ferr0/ferrnorm0)//.chooseresult;
ferr1=(ferr1/ferrnorm1)//.chooseresult;
ferr2=(ferr2/ferrnorm2)//.chooseresult;

ferrtotal=Join[{ferr0},ferr1,ferr2];
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["2ferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
complexprims=myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
If[complexprims==1,MyPrint["2complexprims"];];
If[ferrabs==0 && ferrabsim==0 || ferrabs<badtol&& ferrabsim<badtol&&complexprims==False,resulttype11="Good",resulttype11="Bad"];
Print["2",resulttype11," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " cc=",cc];
Print["2UUi ",rhouu0i," ",Rudi," ",Tudi, " ", Sci];
Print["2UU ",rhou[[1]]//.chooseresult, " ",Rud[[1]]//.chooseresult," ",Tud[[1]]//.chooseresult," ",Sc//.chooseresult];
chooseresultUU0=chooseresult;
ccUU0=ccUU0+cc;
ccUU0max=Max[ccUU0max,cc];
errorUU0=errorUU0+ferrabs+ferrabsim;
errorUU0max=Max[errorUU0max,ferrabs+ferrabsim];
Print["W and W' ",W//.chooseresult," ",Wp//.chooseresult];
If[Re[(u//.chooseresult)]<=0,MyPrint["2resultnegu"];];
If[Re[(rho//.chooseresult)]<=0,MyPrint["2resultnegrho"];];
If[Re[(Er//.chooseresult)]<=0,MyPrint["2resultnegEr"];];
If[myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol,MyPrint["2resultcomplexu"];];
If[myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol,MyPrint["2resultcomplexrho"];];
If[myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol,MyPrint["2resultcomplexEr"];];

ochooseresult=myReP[chooseresult];
p2plist={rho,u,uut1,uut2,uut3,Bcon[[1]],Bcon[[2]],Bcon[[3]],Er,urut1,urut2,urut3}//.ochooseresult;
FullOutput={
"2which(myj,failtype,myid,failnum)",myj,failtype,myid,failnum,
"2resulttype",resulttype11,
"2errorabs",ferrabs+ferrabsim,
"2iters=",cc,
"2p",p2plist,
"2ucon",ucon//.ochooseresult,
"2uradcon",uradcon//.ochooseresult,
"2UU",rhou[[1]]//.ochooseresult,Tud[[1]]//.ochooseresult,Rud[[1]]//.ochooseresult,Re[Sc]//.ochooseresult
};
FullOutput=Flatten[FullOutput];
numFullOutput=Length[FullOutput];
Do[Write[sout,FullOutput[[ii]]],{ii,1,numFullOutput}];

];

(* default *)
resulttype4MS="Bad" ;
resulttype3="Bad";
resulttype4S="Bad" ;
resulttype8="Bad" ;

(* normal full inversion *)
If[doradonly==0,
ferr0=rhou[[1]]-rho0;
(*dt=0*)
ferr1=Table[(Rud[[1,ii]]-Rud0[[ii]])+dt*Gd[[ii]],{ii,1,4}];
ferr2=Table[(Tud[[1,ii]]-Tud0[[ii]])-dt*Gd[[ii]],{ii,1,4}];

(* overwrite lab-frame energy version with fluid-frame energy version *)
jj=1;
If[whichmhd==2,
ferr1[[jj]]=ferr1.ucon;
ferr2[[jj]]=ferr2.ucon;
];
If[whichmhd==3,
(* only contract original equation with ucon for partial comoving frame *)
Rudff=Rud.ucon;
Erff=ucov.Rud.ucon;
Tudff=Tud.ucon;
Rud0ff=Rud0.ucon;
Tud0ff=Tud0.ucon;
Gdff=Gd.ucon;
dtau=dt/ucon[[1]];
 (* use analytic source that Ramesh says is biggest issue.  Note below is just like multiplying by ucon, but Gdff written more analytically apart from Erff.  No use of dtau here. *)
Gdff=-(-kappa*Erff+lambda);
ferr1[[jj]]=(Rudff[[1]]-Rud0ff)+dt*Gdff;
(* Tudff[[1]] = Tud0ff + dt*Gdff means lambda>0 gives Gdff<0 means Tudff[[1]] should drop *)
ferr2[[jj]]=(Tudff[[1]]-Tud0ff)-dt*Gdff;
];
If[whichmhd==4,
(* fully comoving frame.  Contract entire equation on left by ucov and on right by ucon . *)
Rudff=ucov.Rud.ucon;
Erff=ucov.Rud.ucon;
Tudff=ucov.Tud.ucon;
(* (rho + u + P + bsq) u^\mu u_ \n u + \delta^\mu_\n u (P+bsq/2) - b^\mu b_ \n u *)
Tudff=(u+bsq/2);
Rud0ff=Rudff//.chooseresultUU0;
Tud0ff=Tudff//.chooseresultUU0;
Gdff=Gd.ucon;
dtau=dt*ucov[[1]]; (* correct fully comoving quantity *)
(* lambda>0 means Gdff>0 means dtau*Gdff<0 means cooling gas means Tudff should drop *)
Gdff=(-kappa*Erff+lambda);
(* Tudff = Tud0ff + dtau Gdff, so Gdff<0 means Tudff drops as required *)
ferr1[[jj]]=(Rudff-Rud0ff)+dtau*Gdff;
ferr2[[jj]]=(Tudff-Tud0ff)-dtau*Gdff;
];


Print["0FindRoot"];
If[CheckJacobian==1,
gold=1;
];
(*DampingFactor->2,*)
If[COUNTFINDROOT==1,
resultorig=Block[{cc=0},{FindRoot[{ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[2]]==0,ferr2[[3]]==0,ferr2[[4]]==0},ICpin,WorkingPrecision->normalwprec,MaxIterations->normaliters,AccuracyGoal->normaltolprec,PrecisionGoal->normaltolprec,Jacobian->JacobianType ,StepMonitor:>cc++],cc}];result=resultorig[[1]];cc=resultorig[[2]];
(* , Jacobian->FiniteDifference *) (* shows how Symbolic Jacobian is crucial *)
,
resultorig=FindRoot[{ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[2]]==0,ferr2[[3]]==0,ferr2[[4]]==0},ICpin,WorkingPrecision->normalwprec,MaxIterations->normaliters,AccuracyGoal->normaltolprec,PrecisionGoal->normaltolprec, Jacobian->JacobianType , StepMonitor:>Print["Step to:",rho," ",u," ",uu1," ",uu2," ",uu3," ",Er," ",uru1," ",uru2," ",uru3]];result=resultorig;
];
chooseresult=result;
Print["0result=",chooseresult];
Print["Pb=",Pb//.chooseresult];

ferrnorm0=Abs[rhou[[1]]]+Abs[rho0];
ferrnorm1t=Table[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rud0[[ii]]])+Abs[dt*Gd[[ii]]]),{ii,1,1}];
ferrnorm1s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rud0[[ii]]])+Abs[dt*Gd[[ii]]]),{ii,2,4}];
ferrnorm1={ferrnorm1t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm1s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm1s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm1s/Sqrt[Abs[gcon[[4,4]]]]};
ferrnorm2t=Table[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Tud[[1,ii]]]+Abs[Tud0[[ii]]])+Abs[dt*Gd[[ii]]]),{ii,1,1}];
ferrnorm2s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Tud[[1,ii]]]+Abs[Tud0[[ii]]])+Abs[dt*Gd[[ii]]]),{ii,2,4}];
ferrnorm2={ferrnorm2t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm2s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm2s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm2s/Sqrt[Abs[gcon[[4,4]]]]};
ferr0=(ferr0/ferrnorm0)//.chooseresult;
ferr1=(ferr1/ferrnorm1)//.chooseresult;
ferr2=(ferr2/ferrnorm2)//.chooseresult;

ferrtotal=Join[{ferr0},ferr1,ferr2];
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["0ferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
(* only look at densities since velocities can be very small in one component and ok *)
complexprims=myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
Print["0 complex prims=",complexprims];
If[complexprims==1,MyPrint["0complexprims"];];
If[ferrabs==0 && ferrabsim==0 || ferrabs<badtol && ferrabsim<badtol &&complexprims==False,resulttype3="Good",resulttype3="Bad"];
Print["0",resulttype3," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " cc=",cc];
If[resulttype3=="Good",
cc0=cc0+cc;
cc0max=Max[cc0max,cc];
error0=error0+ferrabs+ferrabsim;
error0max=Max[error0max,ferrabs+ferrabsim];
If[Re[(u//.chooseresult)]<=0,MyPrint["0resultnegu"];];
If[Re[(u//.chooseresult)]>0,MyPrint["0resultposu"];];
If[Re[(rho//.chooseresult)]<=0,MyPrint["0resultnegrho"];];
If[Re[(Er//.chooseresult)]<=0,MyPrint["0resultnegEr"];];
If[myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol,MyPrint["0resultcomplexu"];];
If[myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol,MyPrint["0resultcomplexrho"];];
If[myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol,MyPrint["0resultcomplexEr"];];
];
chooseresult0=chooseresult;
ferrabs0=ferrabs+ferrabsim; 

Print["0W and W' ",W//.chooseresult," ",Wp//.chooseresult];
Print["0DD",DD//.chooseresult];
Print["0UUi ",rhouu0i," ",Rudi," ",Tudi, " ", Sci];
Print["0UU ",rhou[[1]]//.chooseresult, " ",Rud[[1]]//.chooseresult," ",Tud[[1]]//.chooseresult," ",Sc//.chooseresult];
Print["0dt*Gd=",dt*Gd//.chooseresult];
Print["0term0=",(rho)*ucon[[1]]//.chooseresult];
Print["0term1=",(rho+u+P+bsq)*ucon[[1]]*ucov[[1]]//.chooseresult];
Print["0term1a=",(rho+u+P+bsq)//.chooseresult];
Print["0term1b=",ucon[[1]]//.chooseresult];
Print["0term1c=",ucov[[1]]//.chooseresult];
Print["0term2=",(P+bsq/2)//.chooseresult];
Print["0term2a=",P//.chooseresult];
Print["0term2b=",(bsq/2)//.chooseresult];
Print["0term3=",-bcon[[1]]*bcov[[1]]//.chooseresult];
Print["0uu0=",uu0//.chooseresult," uru0=",uru0//.chooseresult];
Print["0ucon=",ucon//.chooseresult];
Print["0uradcon=",uradcon//.chooseresult];

ochooseresult=myReP[chooseresult];
p0plist={rho,u,uut1,uut2,uut3,Bcon[[1]],Bcon[[2]],Bcon[[3]],Er,urut1,urut2,urut3}//.ochooseresult;
FullOutput={
"0which(myj,failtype,myid,failnum)",myj,failtype,myid,failnum,
"0resulttype",resulttype3,
"0errorabs",ferrabs+ferrabsim,
"0iters=",cc,
"0p",p0plist,
"0ucon",ucon//.ochooseresult,
"0uradcon",uradcon//.ochooseresult,
"0UU",rhou[[1]]//.ochooseresult,Tud[[1]]//.ochooseresult,Rud[[1]]//.ochooseresult,Re[Sc]//.ochooseresult
};
FullOutput=Flatten[FullOutput];
numFullOutput=Length[FullOutput];
Do[Write[sout,FullOutput[[ii]]],{ii,1,numFullOutput}];

];

(* get inversion of UU0 for entropy (i.e. no source term) *)
If[doradonly==0,
ferr0=rhou[[1]]-rho0;
dtcold=0;
ferr1=Table[(Rud[[1,ii]]-Rud0[[ii]])+dtcold*Gd[[ii]],{ii,1,4}];
ferr2=Table[(Tud[[1,ii]]-Tud0[[ii]])-dtcold*Gd[[ii]],{ii,1,4}];
(* entropy error function still function of u, not changing independent variable to S or anything like that *)
ferr2[[1]]=T*(Sc-Sc0 -dtcold*GS); (* lab-frame version *)

Print["0SnoGFindRoot"];
(*DampingFactor->2,*)
resultorig=Block[{cc=0},{FindRoot[{ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[2]]==0,ferr2[[3]]==0,ferr2[[4]]==0},ICpin,WorkingPrecision->Uwprec,MaxIterations->normaliters,AccuracyGoal->Utolprec,PrecisionGoal->Utolprec, Jacobian->JacobianType,StepMonitor:>cc++],cc}];result=resultorig[[1]];cc=resultorig[[2]];
chooseresult=result;
Print["0SnoGresult=",chooseresult];

ferrnorm0=Abs[rhou[[1]]]+Abs[rho0];
ferrnorm1t=Table[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rud0[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,1,1}];
ferrnorm1s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rud0[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,2,4}];
ferrnorm1={ferrnorm1t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm1s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm1s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm1s/Sqrt[Abs[gcon[[4,4]]]]};
ferrnorm2t=(Abs[T]*(Abs[Sc]+Abs[Sc0]+Abs[dtcold*GS]));
ferrnorm2s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Tud[[1,ii]]]+Abs[Tud0[[ii]]])+Abs[dtcold*Gd[[ii]]]),{ii,2,4}];
ferrnorm2={ferrnorm2t[[1]],ferrnorm2s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm2s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm2s/Sqrt[Abs[gcon[[4,4]]]]};
ferr0=(ferr0/ferrnorm0)//.chooseresult;
ferr1=(ferr1/ferrnorm1)//.chooseresult;
ferr2=(ferr2/ferrnorm2)//.chooseresult;

ferrtotal=Join[{ferr0},ferr1,ferr2];
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["0SnoGferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
complexprims=myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
If[complexprims==1,MyPrint["0Scomplexprims"];];
If[ferrabs==0 && ferrabsim==0 || ferrabs<badtol && ferrabsim<badtol&&complexprims==False,resulttype4SnoG="Good",resulttype4SnoG="Bad"];
Print["0SnoG",resulttype4SnoG," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " cc=",cc];
chooseresultUU0noG=chooseresult;
ccUU0S=ccUU0S+cc;
ccUU0Smax=Max[ccUU0Smax,cc];
errorUU0S=errorUU0S+ferrabs+ferrabsim;
errorUU0Smax=Max[errorUU0Smax,ferrabs+ferrabsim];
If[Re[(u//.chooseresult)]<=0,MyPrint["0SnoGresultnegu"];];
If[Re[(rho//.chooseresult)]<=0,MyPrint["0SnoGresultnegrho"];];
If[Re[(Er//.chooseresult)]<=0,MyPrint["0SnoGresultnegEr"];];
If[myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol,MyPrint["0SnoGresultcomplexu"];];
If[myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol,MyPrint["0SnoGresultcomplexrho"];];
If[myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol,MyPrint["0SnoGresultcomplexEr"];];

ochooseresult=myReP[chooseresult];
p2Splist={rho,u,uut1,uut2,uut3,Bcon[[1]],Bcon[[2]],Bcon[[3]],Er,urut1,urut2,urut3}//.ochooseresult;
FullOutput={
"2Swhich(myj,failtype,myid,failnum)",myj,failtype,myid,failnum,
"2Sresulttype",resulttype4SnoG,
"2Serrorabs",ferrabs+ferrabsim,
"2Siters=",cc,
"2Sp",p2Splist,
"2Sucon",ucon//.ochooseresult,
"2Suradcon",uradcon//.ochooseresult,
"2SUU",rhou[[1]]//.ochooseresult,Tud[[1]]//.ochooseresult,Rud[[1]]//.ochooseresult,Re[Sc]//.ochooseresult
};
FullOutput=Flatten[FullOutput];
numFullOutput=Length[FullOutput];
Do[Write[sout,FullOutput[[ii]]],{ii,1,numFullOutput}];

];

(* normal but uses entropy instead of energy equation *)
If[doradonly==0,
ferr0=rhou[[1]]-rho0;
(*dt=0*)
ferr1=Table[(Rud[[1,ii]]-Rud0[[ii]])+dt*Gd[[ii]],{ii,1,4}];
ferr2=Table[(Tud[[1,ii]]-Tud0[[ii]])-dt*Gd[[ii]],{ii,1,4}];

ferrnorm0=Abs[rhou[[1]]]+Abs[rho0];
ferrnorm1t=Table[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rud0[[ii]]])+Abs[dt*Gd[[ii]]]),{ii,1,1}];
ferrnorm1s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rud0[[ii]]])+Abs[dt*Gd[[ii]]]),{ii,2,4}];
ferrnorm1={ferrnorm1t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm1s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm1s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm1s/Sqrt[Abs[gcon[[4,4]]]]};
ferrnorm2s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Tud[[1,ii]]]+Abs[Tud0[[ii]]])+Abs[dt*Gd[[ii]]]),{ii,2,4}];

(* entropy error function still function of u, not changing independent variable to S or anything like that *)
If[whichentropy==1,
ferr2[[1]]=T*(Sc-Sc0 -dt*GS); (* lab-frame version *)
ferrnorm2t=(Abs[T]*(Abs[Sc]+Abs[Sc0]+Abs[dt*GS]));
];
If[whichentropy==2,
ferr2[[1]]=(u-uii)-(gam u/rho) (rho-rhoii) - (kappa Er - lambda) dt/ucon[[1]]; (* approximate fluid-frame version *)
ferrnorm2t=Abs[(u+uii)+(gam u/rho) (rho+rhoii) + (kappa Er+- lambda) dt/ucon[[1]]];
];
If[whichentropy==3,
Erff=ucov.Rud.ucon;
(*ferr2[[1]]=(u-uii)-(gam u/rho) (rho-rhoii) - (kappa Erff - lambda) dt/ucon[[1]]; (* accurate fluid-frame version *)*)
(* lambda>0 means gas entropy should drop, and have TSc=Tsc0+(kappa Erff-lambda)dt/ut *)
ferr2[[1]]=T*(Sc/ucon[[1]]-Sc0/uu0ii)- (kappa Erff - lambda) dt/ucon[[1]]; (* accurate fluid-frame version *)
ferrnorm2t=Abs[T*(Abs[Sc]/ucon[[1]]+Abs[Sc0]/uu0ii)- (kappaAbs[ Erff] - Abs[lambda]) dt/ucon[[1]]];
];
If[whichentropy==4,
(* fully fluid-frame version *)
Erff=ucov.Rud.ucon;
Scff=ucov.(Sc/ucon[[1]]*ucon); (* i.e. u\mu S u^\mu   *)
Scff=-S;
Sc0ff=Scff//.chooseresultUU0noG;
dtau=ucov[[1]]*dt;
(* lambda>0 means gas entropy should drop means Scff rises, and have TScff = TSc0ff + (kappa Erff - lambda)*dtau = Tsc0ff + (+#) *)
ferr2[[1]]=T*(Scff-Sc0ff)- (kappa Erff - lambda) dtau; 
ferrnorm2t=Abs[T*(Abs[Scff]+Abs[Sc0ff])+(kappa Erff + lambda) dtau]; 
];
(* grep 0SGood math.out|wc;grep 0WSGood math.out|wc;grep 0WSBad math.out|wc *)
(* grep 0Good math.out|wc;grep 0WGood math.out|wc;grep 0WBad math.out|wc *)
ferrnorm2={ferrnorm2t[[1]],ferrnorm2s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm2s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm2s/Sqrt[Abs[gcon[[4,4]]]]};

Print["0SFindRoot"];
If[CheckJacobian==1,
gold=1;
];
(*DampingFactor->2,*)
If[COUNTFINDROOT==1,
resultorig=Block[{cc=0},{FindRoot[{ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[2]]==0,ferr2[[3]]==0,ferr2[[4]]==0},ICpin,WorkingPrecision->normalwprec,MaxIterations->normaliters,AccuracyGoal->normaltolprec,PrecisionGoal->normaltolprec, Jacobian->JacobianType,StepMonitor:>cc++],cc}];result=resultorig[[1]];cc=resultorig[[2]];
(* , Jacobian->FiniteDifference *) (* shows how Symbolic Jacobian is crucial *)
,
resultorig=FindRoot[{ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[2]]==0,ferr2[[3]]==0,ferr2[[4]]==0},ICpin,WorkingPrecision->normalwprec,MaxIterations->normaliters,AccuracyGoal->normaltolprec,PrecisionGoal->normaltolprec, Jacobian->JacobianType, StepMonitor:>Print["Step to:",rho," ",u," ",uu1," ",uu2," ",uu3," ",Er," ",uru1," ",uru2," ",uru3]];result=resultorig;
];
chooseresult=result;
Print["0Sresult=",chooseresult];

ferr0=(ferr0/ferrnorm0)//.chooseresult;
ferr1=(ferr1/ferrnorm1)//.chooseresult;
ferr2=(ferr2/ferrnorm2)//.chooseresult;

ferrtotal=Join[{ferr0},ferr1,ferr2];
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["0Sferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
complexprims=myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
If[complexprims==1,MyPrint["0Scomplexprims"];];
If[ferrabs==0 && ferrabsim==0 || ferrabs<badtol && ferrabsim<badtol&&complexprims==False,resulttype4S="Good",resulttype4S="Bad"];
Print["0S",resulttype4S," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " cc=",cc];
If[resulttype4S=="Good",
cc0S=cc0S+cc;
cc0Smax=Max[cc0Smax,cc];
error0S=error0S+ferrabs+ferrabsim;
error0Smax=Max[error0Smax,ferrabs+ferrabsim];
If[Re[(u//.chooseresult)]<=0,MyPrint["0Sresultnegu"];];
If[Re[(u//.chooseresult)]>0,MyPrint["0Sresultposu"];];
If[Re[(rho//.chooseresult)]<=0,MyPrint["0Sresultnegrho"];];
If[Re[(Er//.chooseresult)]<=0,MyPrint["0SresultnegEr"];];
If[myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol,MyPrint["0Sresultcomplexu"];];
If[myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol,MyPrint["0Sresultcomplexrho"];];
If[myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol,MyPrint["0SresultcomplexEr"];];
];
ochooseresult=myReP[chooseresult];
p0Splist={rho,u,uut1,uut2,uut3,Bcon[[1]],Bcon[[2]],Bcon[[3]],Er,urut1,urut2,urut3}//.ochooseresult;
FullOutput={
"0Swhich(myj,failtype,myid,failnum)",myj,failtype,myid,failnum,
"0Sresulttype",resulttype4S,
"0Serrorabs",ferrabs+ferrabsim,
"0Siters=",cc,
"0Sp",p0Splist,
"0Sucon",ucon//.ochooseresult,
"0Suradcon",uradcon//.ochooseresult,
"0SUU",rhou[[1]]//.ochooseresult,Tud[[1]]//.ochooseresult,Rud[[1]]//.ochooseresult,Re[Sc]//.ochooseresult
};
FullOutput=Flatten[FullOutput];
numFullOutput=Length[FullOutput];
Do[Write[sout,FullOutput[[ii]]],{ii,1,numFullOutput}];

chooseresult0S=chooseresult;
ferrabs0S=ferrabs+ferrabsim; (* overwrite *)

Print["0SW and W' ",W//.chooseresult," ",Wp//.chooseresult];
Print["0SDD",DD//.chooseresult];
Print["0SUU ",rhou[[1]]//.chooseresult, " ",Rud[[1]]//.chooseresult," ",Tud[[1]]//.chooseresult];
Print["0Sdt*Gd=",dt*Gd//.chooseresult];
Print["0Sterm0=",(rho)*ucon[[1]]//.chooseresult];
Print["0Sterm1=",(rho+u+P+bsq)*ucon[[1]]*ucov[[1]]//.chooseresult];
Print["0Sterm1a=",(rho+u+P+bsq)//.chooseresult];
Print["0Sterm1b=",ucon[[1]]//.chooseresult];
Print["0Sterm1c=",ucov[[1]]//.chooseresult];
Print["0Sterm2=",(P+bsq/2)//.chooseresult];
Print["0Sterm2a=",P//.chooseresult];
Print["0Sterm2b=",(bsq/2)//.chooseresult];
Print["0Sterm3=",-bcon[[1]]*bcov[[1]]//.chooseresult];
Print["0Suu0=",uu0//.chooseresult," uru0=",uru0//.chooseresult];
Print["0Sucon=",ucon//.chooseresult];
Print["0Suradcon=",uradcon//.chooseresult];
];

(* normal radiation only *)
If[doradonly==1,
ferr1=Table[(Rud[[1,ii]]-Rud0[[ii]]),{ii,1,4}];
Print["0RADFindRoot"];
(*DampingFactor->2,*)
If[COUNTFINDROOT==1,
resultorig=Block[{cc=0},{FindRoot[{ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0},ICpinrad,WorkingPrecision->normalwprec,MaxIterations->normaliters,AccuracyGoal->normaltolprec,PrecisionGoal->normaltolprec, Jacobian->JacobianType, StepMonitor:>cc++],cc}];result=resultorig[[1]];cc=resultorig[[2]];
,
resultorig=FindRoot[{ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0},ICpinrad,WorkingPrecision->normalwprec,MaxIterations->normaliters,AccuracyGoal->normaltolprec,PrecisionGoal->normaltolprec, Jacobian->JacobianType, StepMonitor:>Print["Step to: ",Er," ",uru1," ",uru2," ",uru3]];result=resultorig;
];
chooseresult=result;
Print["0RADresult=",chooseresult];
ferr1=(ferr1/Max[Abs[(Er//.chooseresult)],Abs[(Er//.chooseresult)]])//.chooseresult;
ferrtotal=ferr1;
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["0RADferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
complexprims=myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
If[complexprims==1,MyPrint["0RADcomplexprims"];];
If[ferrabs==0 && ferrabsim==0 || ferrabs<badtol && ferrabsim<badtol&&complexprims==False,resulttype5="Good",resulttype5="Bad"];
Print["0RAD",resulttype5," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " cc=",cc];
Print["UU ",Rud[[1]]//.chooseresult];
];


(* normal but more working precision to test if matters *)
If[resulttype3=="Bad" &&doradonly==0&&dohighprec==1,
ferr0=rhou[[1]]-rho0;
ferr0norm=10^(-300)+Abs[rhou[[1]]]+Abs[rho0];
(*dt=0*)
ferr1=Table[(Rud[[1,ii]]-Rud0[[ii]])+dt*Gd[[ii]],{ii,1,4}];
ferr1norm=10^(-300)+Table[(Abs[Rud[[1,ii]]]+Abs[Rud0[[ii]]])+Abs[dt*Gd[[ii]]],{ii,1,4}];
ferr2=Table[(Tud[[1,ii]]-Tud0[[ii]])-dt*Gd[[ii]],{ii,1,4}];
ferr2norm=10^(-300)+Table[(Abs[Tud[[1,ii]]]+Abs[Tud0[[ii]]])+Abs[dt*Gd[[ii]]],{ii,1,4}];

(* overwrite lab-frame energy version with fluid-frame energy version *)
jj=1;
If[whichmhd==2,
ferr1[[jj]]=ferr1.ucon;
ferr2[[jj]]=ferr2.ucon;
ferr1norm[[jj]]=ferr1norm.ucon;
ferr2norm[[jj]]=ferr2norm.ucon;
];
If[whichmhd==3,
(* only contract original equation with ucon for partial comoving frame *)
Rudff=Rud.ucon;
Erff=ucov.Rud.ucon;
Tudff=Tud.ucon;
Rud0ff=Rud0.ucon;
Tud0ff=Tud0.ucon;
Gdff=Gd.ucon;
dtau=dt/ucon[[1]];
 (* use analytic source that Ramesh says is biggest issue.  Note below is just like multiplying by ucon, but Gdff written more analytically apart from Erff.  No use of dtau here. *)
Gdff=-(-kappa*Erff+lambda);
ferr1[[jj]]=(Rudff[[1]]-Rud0ff)+dt*Gdff;
ferr2[[jj]]=(Tudff[[1]]-Tud0ff)-dt*Gdff;
ferr1norm[[jj]]=10^(-300)+(Abs[Rudff[[1]]]+Abs[Rud0ff])+Abs[dt*Gdff];
ferr2norm[[jj]]=10^(-300)+(Abs[Tudff[[1]]]+Abs[Tud0ff])+Abs[dt*Gdff];
];
If[whichmhd==4,
(* fully comoving frame.  Contract entire equation on left by ucov and on right by ucon . *)
Rudff=ucov.Rud.ucon;
Erff=ucov.Rud.ucon;
(* below doesn't remove rho in comoving frame *)
Tudff=ucov.Tud.ucon;

(* eta_nu = (-alpha,0,0,0) *)
(* gamma = -u^mu eta_nu = (alpha u^t) *)
(* rho u^mu eta_nu/(-alpha u^t) + T^mu_nu = rho u^mu (eta_nu/(-alpha u^t) + u_nu) + (u+p+bsq)u^mu u_nu + delta^mu_nu (p+bsq/2) - b^mu b_nu *)
(* -rho + rho + u + P + bsq - P - bsq/2 = u+bsq/2 *)
(* but this doesn't work for lab-frame version, which works because D=rho0*ut is constant *)

Tudff=(u+bsq/2);
Rud0ff=Rudff//.chooseresultUU0;
Tud0ff=Tudff//.chooseresultUU0;
Gdff=Gd.ucon;
dtau=dt*ucov[[1]]; (* correct fully comoving quantity *)
Gdff=(-kappa*Erff+lambda);
ferr1[[jj]]=(Rudff-Rud0ff)+dtau*Gdff;
ferr2[[jj]]=(Tudff-Tud0ff)-dtau*Gdff;
ferr1norm[[jj]]=10^(-300)+(Abs[Rudff]+Abs[Rud0ff])+Abs[dtau*Gdff];
ferr2norm[[jj]]=10^(-300)+(Abs[Tudff]+Abs[Tud0ff])+Abs[dtau*Gdff];
];


Print["0WFindRoot"];
resultorig=Block[{cc=0},{FindRoot[{ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[2]]==0,ferr2[[3]]==0,ferr2[[4]]==0},ICpin,WorkingPrecision->Wwprec,MaxIterations->Witers,AccuracyGoal->Wtolprec,PrecisionGoal->Wtolprec, Jacobian->JacobianType, StepMonitor:>cc++],cc}];
(*DampingFactor->2,*)
result=resultorig[[1]];cc=resultorig[[2]];
chooseresult=result;
Print["0Wresult=",chooseresult];
(*ferr0=ferr0/Abs[rho]//.chooseresult;
ferr1=(ferr1/Max[Abs[(Er//.chooseresult)],Abs[(Er//.chooseresult)]])//.chooseresult;
ferr2=(ferr2/Max[Abs[(Er//.chooseresult)],Abs[(Er//.chooseresult)]])//.chooseresult;
*)
ferr0=ferr0/ferr0norm//.chooseresult;
ferr1=ferr1/ferr1norm//.chooseresult;
ferr2=ferr2/ferr2norm//.chooseresult;

(*
ferr0=ferr0//.chooseresult;
ferr1=ferr1//.chooseresult;
ferr2=ferr2//.chooseresult;
*)
ferrtotal=Join[{ferr0},ferr1,ferr2];
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["0Wferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
complexprims=myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
If[complexprims==1,MyPrint["0Wcomplexprims"];];
If[ferrabs==0 && ferrabsim==0 || ferrabs<badtol && ferrabsim<badtol&&complexprims==False,resulttype6="Good",resulttype6="Bad"];
Print["0W",resulttype6," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " cc=",cc];
cc0W=cc0W+cc;
cc0Wmax=Max[cc0Wmax,cc];
error0W=error0W+ferrabs+ferrabsim;
error0Wmax=Max[error0Wmax,ferrabs+ferrabsim];
If[Re[(u//.chooseresult)]<=0,MyPrint["0Wresultnegu"];];
If[Re[(rho//.chooseresult)]<=0,MyPrint["0Wresultnegrho"];];
If[Re[(Er//.chooseresult)]<=0,MyPrint["0WresultnegEr"];];
If[myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol,MyPrint["0Wresultcomplexu"];];
If[myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol,MyPrint["0Wresultcomplexrho"];];
If[myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol,MyPrint["0WresultcomplexEr"];];
chooseresult0W=chooseresult;
chooseresult0=chooseresult; (* overwrite if already set *)
ferrabs0W=ferrabs+ferrabsim; 
ferrabs0=ferrabs+ferrabsim; (* overwrite *)

ochooseresult=myReP[chooseresult];
p0Wplist={rho,u,uut1,uut2,uut3,Bcon[[1]],Bcon[[2]],Bcon[[3]],Er,urut1,urut2,urut3}//.ochooseresult;
FullOutput={
"0Wwhich(myj,failtype,myid,failnum)",myj,failtype,myid,failnum,
"0Wresulttype",resulttype6,
"0Werrorabs",ferrabs+ferrabsim,
"0Witers=",cc,
"0Wp",p0Wplist,
"0Wucon",ucon//.ochooseresult,
"0Wuradcon",uradcon//.ochooseresult,
"0WUU",rhou[[1]]//.ochooseresult,Tud[[1]]//.ochooseresult,Rud[[1]]//.ochooseresult,Re[Sc]//.ochooseresult
};
FullOutput=Flatten[FullOutput];
numFullOutput=Length[FullOutput];
Do[Write[sout,FullOutput[[ii]]],{ii,1,numFullOutput}];

];

(* normal but entropy *and* but more working precision to test if matters *)
If[resulttype4S=="Bad" &&doradonly==0&&dohighprec==1,
ferr0=rhou[[1]]-rho0;
(*dt=0*)
ferr1=Table[(Rud[[1,ii]]-Rud0[[ii]])+dt*Gd[[ii]],{ii,1,4}];
ferr2=Table[(Tud[[1,ii]]-Tud0[[ii]])-dt*Gd[[ii]],{ii,1,4}];

ferrnorm0=Abs[rhou[[1]]]+Abs[rho0];
ferrnorm1t=Table[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rud0[[ii]]])+Abs[dt*Gd[[ii]]]),{ii,1,1}];
ferrnorm1s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rud0[[ii]]])+Abs[dt*Gd[[ii]]]),{ii,2,4}];
ferrnorm1={ferrnorm1t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm1s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm1s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm1s/Sqrt[Abs[gcon[[4,4]]]]};
ferrnorm2s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Tud[[1,ii]]]+Abs[Tud0[[ii]]])+Abs[dt*Gd[[ii]]]),{ii,2,4}];

(* entropy error function still function of u, not changing independent variable to S or anything like that *)
If[whichentropy==1,
ferr2[[1]]=T*(Sc-Sc0 -dt*GS); (* lab-frame version *)
ferrnorm2t=(Abs[T]*(Abs[Sc]+Abs[Sc0]+Abs[dt*GS]));
];
If[whichentropy==2,
ferr2[[1]]=(u-uii)-(gam u/rho) (rho-rhoii) - (kappa Er - lambda) dt/ucon[[1]]; (* approximate fluid-frame version *)
ferrnorm2t=Abs[(u+uii)+(gam u/rho) (rho+rhoii) + (kappa Er+- lambda) dt/ucon[[1]]];
];
If[whichentropy==3,
Erff=ucov.Rud.ucon;
(*ferr2[[1]]=(u-uii)-(gam u/rho) (rho-rhoii) - (kappa Erff - lambda) dt/ucon[[1]]; (* accurate fluid-frame version *)*)
(* lambda>0 means gas entropy should drop, and have TSc=Tsc0+(kappa Erff-lambda)dt/ut *)
ferr2[[1]]=T*(Sc/ucon[[1]]-Sc0/uu0ii)- (kappa Erff - lambda) dt/ucon[[1]]; (* accurate fluid-frame version *)
ferrnorm2t=Abs[T*(Abs[Sc]/ucon[[1]]+Abs[Sc0]/uu0ii)- (kappaAbs[ Erff] - Abs[lambda]) dt/ucon[[1]]];
];
If[whichentropy==4,
(* fully fluid-frame version *)
Erff=ucov.Rud.ucon;
Scff=ucov.(Sc/ucon[[1]]*ucon); (* i.e. u\mu S u^\mu   *)
Scff=-S;
Sc0ff=Scff//.chooseresultUU0noG;
dtau=ucov[[1]]*dt;
(* lambda>0 means gas entropy should drop means Scff rises, and have TScff = TSc0ff + (kappa Erff - lambda)*dtau = Tsc0ff + (+#) *)
ferr2[[1]]=T*(Scff-Sc0ff)- (kappa Erff - lambda) dtau; 
ferrnorm2t=Abs[T*(Abs[Scff]+Abs[Sc0ff])+(kappa Erff + lambda) dtau]; 
];
(* grep 0SGood math.out|wc;grep 0WSGood math.out|wc;grep 0WSBad math.out|wc *)
(* grep 0Good math.out|wc;grep 0WGood math.out|wc;grep 0WBad math.out|wc *)
ferrnorm2={ferrnorm2t[[1]],ferrnorm2s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm2s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm2s/Sqrt[Abs[gcon[[4,4]]]]};


Print["0WSFindRoot"];
resultorig=Block[{cc=0},{FindRoot[{ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[2]]==0,ferr2[[3]]==0,ferr2[[4]]==0},ICpin,WorkingPrecision->Wwprec,MaxIterations->Witers,AccuracyGoal->Wtolprec,PrecisionGoal->Wtolprec, Jacobian->JacobianType, StepMonitor:>cc++],cc}];
(*DampingFactor->2,*)
result=resultorig[[1]];cc=resultorig[[2]];
chooseresult=result;
Print["0WSresult=",chooseresult];

ferr0=ferr0/ferr0norm//.chooseresult;
ferr1=ferr1/ferr1norm//.chooseresult;
ferr2=ferr2/ferr2norm//.chooseresult;

ferrtotal=Join[{ferr0},ferr1,ferr2];
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["0WSferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
complexprims=myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
If[complexprims==1,MyPrint["0WScomplexprims"];];
If[ferrabs==0 && ferrabsim==0 || ferrabs<badtol && ferrabsim<badtol&&complexprims==False,resulttype7S="Good",resulttype7S="Bad"];
Print["0WS",resulttype7S," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " cc=",cc];
cc0WS=cc0WS+cc;
cc0WSmax=Max[cc0WSmax,cc];
error0WS=error0WS+ferrabs+ferrabsim;
error0WSmax=Max[error0WSmax,ferrabs+ferrabsim];
If[Re[(u//.chooseresult)]<=0,MyPrint["0WSresultnegu"];];
If[Re[(rho//.chooseresult)]<=0,MyPrint["0WSresultnegrho"];];
If[Re[(Er//.chooseresult)]<=0,MyPrint["0WSresultnegEr"];];
If[myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol,MyPrint["0WSresultcomplexu"];];
If[myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol,MyPrint["0WSresultcomplexrho"];];
If[myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol,MyPrint["0WSresultcomplexEr"];];
chooseresult0WS=chooseresult;
chooseresult0S=chooseresult; (* overwrite if already set *)
ferrabs0WS=ferrabs+ferrabsim;
ferrabs0S=ferrabs+ferrabsim; (* overwrite *)

ochooseresult=myReP[chooseresult];
p0WSplist={rho,u,uut1,uut2,uut3,Bcon[[1]],Bcon[[2]],Bcon[[3]],Er,urut1,urut2,urut3}//.ochooseresult;
FullOutput={
"0WSwhich(myj,failtype,myid,failnum)",myj,failtype,myid,failnum,
"0WSresulttype",resulttype7S,
"0WSerrorabs",ferrabs+ferrabsim,
"0WSiters=",cc,
"0WSp",p0WSplist,
"0WSucon",ucon//.ochooseresult,
"0WSuradcon",uradcon//.ochooseresult,
"0WSUU",rhou[[1]]//.ochooseresult,Tud[[1]]//.ochooseresult,Rud[[1]]//.ochooseresult,Re[Sc]//.ochooseresult
};
FullOutput=Flatten[FullOutput];
numFullOutput=Length[FullOutput];
Do[Write[sout,FullOutput[[ii]]],{ii,1,numFullOutput}];

];



(* Check if entropy should have been used *)
uenergy=Re[(u//.chooseresult0)];
rhogenergy=Re[(rho//.chooseresult0)];
Ergenergy=Re[(Er//.chooseresult0)];

uentropy=Re[(u//.chooseresult0S)];
rhogentropy=Re[(rho//.chooseresult0S)];
Ergentropy=Re[(Er//.chooseresult0S)];
complexentropy=myRe[(u//.chooseresult0S)]<myIm[(u//.chooseresult0S)]/badtol||myRe[(rho//.chooseresult0S)]<myIm[(rho//.chooseresult0S)]/badtol||myRe[(Er//.chooseresult0S)]<myIm[(Er//.chooseresult0S)]/badtol;

If[(uenergy<=0 && uentropy>0 )&&complexentropy==False&&ferrabs0S<badtol,MyPrint["SHOULDUSEENTROPYNEGU"];];
If[(uenergy<=0 && uentropy>0 )&&complexentropy==False&&ferrabs0S>=badtol,MyPrint["SHOULDUSEENTROPYNEGUBUTCANT"];];
If[(uenergy<2*uentropy && uentropy>0)&&complexentropy==False&&ferrabs0S<badtol,MyPrint["SHOULDUSEENTROPYCOND"];];
If[(uenergy<2*uentropy && uentropy>0)&&complexentropy==False&&ferrabs0S>=badtol,MyPrint["SHOULDUSEENTROPYCONDBUTCANT"];];
If[rhoenergy<=0 && rhoentropy>0&&complexentropy==False&&ferrabs0S<badtol,MyPrint["SHOULDUSEENTROPYNEGRHO"];];
If[Erenergy<=0 && Erentropy>0&&complexentropy==False&&ferrabs0S<badtol,MyPrint["SHOULDUSEENTROPYNEGER"];];



If[dogammamax==1,
(* setup gammamax *)
alphasq=1/-SetPrecision[gcon[[1,1]],myprec];
gammarelmax=1000;
gammamax=gammarelmax/alphasq;
If[whichvel==1,
mysolsuru1=Solve[uru0==gammamax,uru1];
Print["GOD: ",mysolsuru1//.consts];
choosesolsuru1=mysolsuru1[[2,1,2]];
mysolsuru1;
];
If[whichvel==2,
mysolsurut1=Solve[uru0==gammamax,urut1];
Print["GOD: ",mysolsurut1//.consts];
choosesolsurut1=mysolsurut1[[2,1,2]];
mysolsurut1;
];
];

(* normal but revert to gammamax if still can't find solution *)
If[dogammamax==1&&resulttype3=="Bad" && doradonly==0,
ferr0=rhou[[1]]-rho0;
(*dt=0*)
ferr1=Table[(Rud[[1,ii]]-Rud0[[ii]])+dt*Gd[[ii]],{ii,1,4}];

(* replace equation for uru1 *)
If[whichvel==1,
ferr1[[1]]=choosesolsuru1-uru1;
];
If[whichvel==2,
ferr1[[1]]=choosesolsurut1-urut1;
];
ferr2=Table[(Tud[[1,ii]]-Tud0[[ii]])-dt*Gd[[ii]],{ii,1,4}];
Print["0MFindRoot"];
resultorig=Block[{cc=0},{FindRoot[{ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[2]]==0,ferr2[[3]]==0,ferr2[[4]]==0},ICpin,WorkingPrecision->Wwprec,MaxIterations->normaliters,AccuracyGoal->Wtolprec,PrecisionGoal->Wtolprec, Jacobian->JacobianType, StepMonitor:>cc++],cc}];
(*DampingFactor->2,*)
result=resultorig[[1]];cc=resultorig[[2]];
chooseresult=result;
Print["0Mresult=",chooseresult];
ferr0=ferr0/Abs[rho]//.chooseresult;
ferr1=(ferr1/Max[Abs[(u//.chooseresult)],Abs[(Er//.chooseresult)]])//.chooseresult;
ferr2=(ferr2/Max[Abs[(u//.chooseresult)],Abs[(Er//.chooseresult)]])//.chooseresult;
ferrtotal=Join[{ferr0},ferr1,ferr2];
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["0Mferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
complexprims=myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
If[complexprims==1,Print["0Mcomplexprims"];];
If[ferrabs==0 && ferrabsim==0 || ferrabs<badtol && ferrabsim<badtol&&complexprims==False,resulttype8="Good",resulttype8="Bad"];
Print["0M",resulttype8," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " cc=",cc];
chooseresult0M=chooseresult;

Print["0MW and W' ",W//.chooseresult," ",Wp//.chooseresult];
Print["0MDD",DD//.chooseresult];
Print["0MUU ",rhou[[1]]//.chooseresult, " ",Rud[[1]]//.chooseresult," ",Tud[[1]]//.chooseresult];
Print["0Mdt*Gd=",dt*Gd//.chooseresult];
Print["0Mterm0=",(rho)*ucon[[1]]//.chooseresult];
Print["0Mterm1=",(rho+u+P+bsq)*ucon[[1]]*ucov[[1]]//.chooseresult];
Print["0Mterm1a=",(rho+u+P+bsq)//.chooseresult];
Print["0Mterm1b=",ucon[[1]]//.chooseresult];
Print["0Mterm1c=",ucov[[1]]//.chooseresult];
Print["0Mterm2=",(P+bsq/2)//.chooseresult];
Print["0Mterm2a=",P//.chooseresult];
Print["0Mterm2b=",(bsq/2)//.chooseresult];
Print["0Mterm3=",-bcon[[1]]*bcov[[1]]//.chooseresult];
Print["0Muu0=",uu0//.chooseresult," uru0=",uru0//.chooseresult];
Print["0Mucon=",ucon//.chooseresult];
Print["0Muradcon=",uradcon//.chooseresult];
];

If[ doradonly==1,
alphasq=1/-SetPrecision[gcon[[1,1]],myprec];
gammarelmax=1000;
gammamax=gammarelmax/alphasq;
mysolsuru1=Solve[uru0==gammamax,uru1];
Print["GODRAD: ",mysolsuru1//.consts];
choosesolsuru1=mysolsuru1[[2,1,2]];
mysolsuru1;
ferr1=Table[(Rud[[1,ii]]-Rud0[[ii]]),{ii,1,4}];
(* replace equation for uru1 *)
ferr1[[1]]=choosesolsuru1-uru1;
Print["0MRADFindRoot"];
resultorig=Block[{cc=0},{FindRoot[{ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0},ICpinrad,WorkingPrecision->Wwprec,MaxIterations->Witers,AccuracyGoal->Wtolprec,PrecisionGoal->Wtolprec, Jacobian->JacobianType, StepMonitor:>cc++],cc}];
(*DampingFactor->2,*)
result=resultorig[[1]];cc=resultorig[[2]];
chooseresult=result;
Print["0MRADresult=",chooseresult];
ferr1=(ferr1/Max[Abs[(Er//.chooseresult)],Abs[(Er//.chooseresult)]])//.chooseresult;
ferrtotal=ferr1;
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["0MRADferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
complexprims=myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
If[complexprims==1,Print["0MRADcomplexprims"];];
If[ferrabs==0 && ferrabsim==0 || ferrabs<badtol && ferrabsim<badtol&&complexprims==False,resulttype9="Good",resulttype9="Bad"];
Print["0MRAD",resulttype9," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " cc=",cc];
];



(* normal but uses entropy instead of energy equation *)
if[dogammamax==1&&resulttype4S=="Bad" &&doradonly==0,
ferr0=rhou[[1]]-rho0;
(*dt=0*)
ferr1=Table[(Rud[[1,ii]]-Rud0[[ii]])+dt*Gd[[ii]],{ii,1,4}];
(* replace equation for uru1 *)
If[whichvel==1,
ferr1[[1]]=choosesolsuru1-uru1;
];
If[whichvel==2,
ferr1[[1]]=choosesolsurut1-urut1;
];
ferr2=Table[(Tud[[1,ii]]-Tud0[[ii]])-dt*Gd[[ii]],{ii,1,4}];

ferrnorm0=Abs[rhou[[1]]]+Abs[rho0];
ferrnorm1t=Table[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rud0[[ii]]])+Abs[dt*Gd[[ii]]]),{ii,1,1}];
ferrnorm1s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Rud[[1,ii]]]+Abs[Rud0[[ii]]])+Abs[dt*Gd[[ii]]]),{ii,2,4}];
ferrnorm1={ferrnorm1t[[1]]/Sqrt[Abs[gcon[[1,1]]]],ferrnorm1s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm1s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm1s/Sqrt[Abs[gcon[[4,4]]]]};
ferrnorm2s=Sum[Sqrt[Abs[gcon[[ii,ii]]]]*((Abs[Tud[[1,ii]]]+Abs[Tud0[[ii]]])+Abs[dt*Gd[[ii]]]),{ii,2,4}];

(* entropy error function still function of u, not changing independent variable to S or anything like that *)
If[whichentropy==1,
ferr2[[1]]=T*(Sc-Sc0 -dt*GS); (* lab-frame version *)
ferrnorm2t=(Abs[T]*(Abs[Sc]+Abs[Sc0]+Abs[dt*GS]));
];
If[whichentropy==2,
ferr2[[1]]=(u-uii)-(gam u/rho) (rho-rhoii) - (kappa Er - lambda) dt/ucon[[1]]; (* approximate fluid-frame version *)
ferrnorm2t=Abs[(u+uii)+(gam u/rho) (rho+rhoii) + (kappa Er+- lambda) dt/ucon[[1]]];
];
If[whichentropy==3,
Erff=ucov.Rud.ucon;
(*ferr2[[1]]=(u-uii)-(gam u/rho) (rho-rhoii) - (kappa Erff - lambda) dt/ucon[[1]]; (* accurate fluid-frame version *)*)
(* lambda>0 means gas entropy should drop, and have TSc=Tsc0+(kappa Erff-lambda)dt/ut *)
ferr2[[1]]=T*(Sc/ucon[[1]]-Sc0/uu0ii)- (kappa Erff - lambda) dt/ucon[[1]]; (* accurate fluid-frame version *)
ferrnorm2t=Abs[T*(Abs[Sc]/ucon[[1]]+Abs[Sc0]/uu0ii)- (kappaAbs[ Erff] - Abs[lambda]) dt/ucon[[1]]];
];
If[whichentropy==4,
(* fully fluid-frame version *)
Erff=ucov.Rud.ucon;
Scff=ucov.(Sc/ucon[[1]]*ucon); (* i.e. u\mu S u^\mu   *)
Scff=-S;
Sc0ff=Scff//.chooseresultUU0noG;
dtau=ucov[[1]]*dt;
(* lambda>0 means gas entropy should drop means Scff rises, and have TScff = TSc0ff + (kappa Erff - lambda)*dtau = Tsc0ff + (+#) *)
ferr2[[1]]=T*(Scff-Sc0ff)- (kappa Erff - lambda) dtau; 
ferrnorm2t=Abs[T*(Abs[Scff]+Abs[Sc0ff])+(kappa Erff + lambda) dtau]; 
];
(* grep 0MSGood math.out|wc;grep 0WSGood math.out|wc;grep 0WSBad math.out|wc *)
(* grep 0Good math.out|wc;grep 0WGood math.out|wc;grep 0WBad math.out|wc *)
ferrnorm2={ferrnorm2t[[1]],ferrnorm2s/Sqrt[Abs[gcon[[2,2]]]],ferrnorm2s/Sqrt[Abs[gcon[[3,3]]]],ferrnorm2s/Sqrt[Abs[gcon[[4,4]]]]};

Print["0MSFindRoot"];
If[CheckJacobian==1,
gold=1;
];
(*DampingFactor->2,*)
If[COUNTFINDROOT==1,
resultorig=Block[{cc=0},{FindRoot[{ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[2]]==0,ferr2[[3]]==0,ferr2[[4]]==0},ICpin,WorkingPrecision->normalwprec,MaxIterations->normaliters,AccuracyGoal->normaltolprec,PrecisionGoal->normaltolprec, Jacobian->JacobianType,StepMonitor:>cc++],cc}];result=resultorig[[1]];cc=resultorig[[2]];
(* , Jacobian->FiniteDifference *) (* shows how Symbolic Jacobian is crucial *)
,
resultorig=FindRoot[{ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[2]]==0,ferr2[[3]]==0,ferr2[[4]]==0},ICpin,WorkingPrecision->normalwprec,MaxIterations->normaliters,AccuracyGoal->normaltolprec,PrecisionGoal->normaltolprec, Jacobian->JacobianType, StepMonitor:>Print["Step to:",rho," ",u," ",uu1," ",uu2," ",uu3," ",Er," ",uru1," ",uru2," ",uru3]];result=resultorig;
];
chooseresult=result;
Print["0MSresult=",chooseresult];

ferr0=(ferr0/ferrnorm0)//.chooseresult;
ferr1=(ferr1/ferrnorm1)//.chooseresult;
ferr2=(ferr2/ferrnorm2)//.chooseresult;

ferrtotal=Join[{ferr0},ferr1,ferr2];
ferrabs=Sqrt[myRe[ferrtotal].myRe[ferrtotal]];
ferrabsim=Sqrt[myIm[ferrtotal].myIm[ferrtotal]];
Print["0MSferr=",ferrtotal,"ferrabs=",ferrabs,"ferrabsim=",ferrabsim];
complexprims=myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol||myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol||myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol;
If[complexprims==1,MyPrint["0MScomplexprims"];];
If[ferrabs==0 && ferrabsim==0 || ferrabs<badtol && ferrabsim<badtol&&complexprims==False,resulttype4MS="Good",resulttype4MS="Bad"];
Print["0MS",resulttype4MS," ",CForm[ferrabs+ferrabsim]," ",myj," ",failtype," ",myid," ",failnum, " cc=",cc];
If[resulttype4MS=="Good",
(*
cc0MS=cc0MS+cc;
cc0MSmax=Max[cc0MSmax,cc];
error0MS=error0MS+ferrabs+ferrabsim;
error0MSmax=Max[error0MSmax,ferrabs+ferrabsim];
*)
If[Re[(u//.chooseresult)]<=0,MyPrint["0MSresultnegu"];];
If[Re[(u//.chooseresult)]>0,MyPrint["0MSresultposu"];];
If[Re[(rho//.chooseresult)]<=0,MyPrint["0MSresultnegrho"];];
If[Re[(Er//.chooseresult)]<=0,MyPrint["0MSresultnegEr"];];
If[myRe[(u//.chooseresult)]<myIm[(u//.chooseresult)]/badtol,MyPrint["0MSresultcomplexu"];];
If[myRe[(rho//.chooseresult)]<myIm[(rho//.chooseresult)]/badtol,MyPrint["0MSresultcomplexrho"];];
If[myRe[(Er//.chooseresult)]<myIm[(Er//.chooseresult)]/badtol,MyPrint["0MSresultcomplexEr"];];
];
ochooseresult=myReP[chooseresult];
p0MSplist={rho,u,uut1,uut2,uut3,Bcon[[1]],Bcon[[2]],Bcon[[3]],Er,urut1,urut2,urut3}//.ochooseresult;
FullOutput={
"0MSwhich(myj,failtype,myid,failnum)",myj,failtype,myid,failnum,
"0MSresulttype",resulttype4MS,
"0MSerrorabs",ferrabs+ferrabsim,
"0MSiters=",cc,
"0MSp",p0MSplist,
"0MSucon",ucon//.ochooseresult,
"0MSuradcon",uradcon//.ochooseresult,
"0MSUU",rhou[[1]]//.ochooseresult,Tud[[1]]//.ochooseresult,Rud[[1]]//.ochooseresult,Re[Sc]//.ochooseresult
};
FullOutput=Flatten[FullOutput];
numFullOutput=Length[FullOutput];
Do[Write[sout,FullOutput[[ii]]],{ii,1,numFullOutput}];

chooseresult0MS=chooseresult;
ferrabs0MS=ferrabs+ferrabsim; (* overwrite *)

Print["0MSW and W' ",W//.chooseresult," ",Wp//.chooseresult];
Print["0MSDD",DD//.chooseresult];
Print["0MSUU ",rhou[[1]]//.chooseresult, " ",Rud[[1]]//.chooseresult," ",Tud[[1]]//.chooseresult];
Print["0MSdt*Gd=",dt*Gd//.chooseresult];
Print["0MSterm0=",(rho)*ucon[[1]]//.chooseresult];
Print["0MSterm1=",(rho+u+P+bsq)*ucon[[1]]*ucov[[1]]//.chooseresult];
Print["0MSterm1a=",(rho+u+P+bsq)//.chooseresult];
Print["0MSterm1b=",ucon[[1]]//.chooseresult];
Print["0MSterm1c=",ucov[[1]]//.chooseresult];
Print["0MSterm2=",(P+bsq/2)//.chooseresult];
Print["0MSterm2a=",P//.chooseresult];
Print["0MSterm2b=",(bsq/2)//.chooseresult];
Print["0MSterm3=",-bcon[[1]]*bcov[[1]]//.chooseresult];
Print["0MSuu0=",uu0//.chooseresult," uru0=",uru0//.chooseresult];
Print["0MSucon=",ucon//.chooseresult];
Print["0MSuradcon=",uradcon//.chooseresult];
];


uenergy=Re[(u//.chooseresult0)];
rhogenergy=Re[(rho//.chooseresult0)];
Ergenergy=Re[(Er//.chooseresult0)];
complexenergy=myRe[(u//.chooseresult0)]<myIm[(u//.chooseresult0)]/badtol||myRe[(rho//.chooseresult0)]<myIm[(rho//.chooseresult0)]/badtol||myRe[(Er//.chooseresult0)]<myIm[(Er//.chooseresult0)]/badtol;

uenergym=Re[(u//.chooseresult0M)];
rhogenergym=Re[(rho//.chooseresult0M)];
Ergenergym=Re[(Er//.chooseresult0M)];
complexenergym=myRe[(u//.chooseresult0M)]<myIm[(u//.chooseresult0M)]/badtol||myRe[(rho//.chooseresult0M)]<myIm[(rho//.chooseresult0M)]/badtol||myRe[(Er//.chooseresult0M)]<myIm[(Er//.chooseresult0M)]/badtol;

uentropy=Re[(u//.chooseresult0S)];
rhogentropy=Re[(rho//.chooseresult0S)];
Ergentropy=Re[(Er//.chooseresult0S)];
complexentropy=myRe[(u//.chooseresult0S)]<myIm[(u//.chooseresult0S)]/badtol||myRe[(rho//.chooseresult0S)]<myIm[(rho//.chooseresult0S)]/badtol||myRe[(Er//.chooseresult0S)]<myIm[(Er//.chooseresult0S)]/badtol;

uentropyms=Re[(u//.chooseresult0MS)];
rhogentropyms=Re[(rho//.chooseresult0MS)];
Ergentropyms=Re[(Er//.chooseresult0MS)];
complexentropyms=myRe[(u//.chooseresult0MS)]<myIm[(u//.chooseresult0MS)]/badtol||myRe[(rho//.chooseresult0MS)]<myIm[(rho//.chooseresult0MS)]/badtol||myRe[(Er//.chooseresult0MS)]<myIm[(Er//.chooseresult0MS)]/badtol;



resultA=If[resulttype4MS=="Bad" && resulttype3=="Bad" && resulttype4S=="Bad"  && resulttype8=="Bad" ,1,0];
resultB=If[resulttype4MS=="Good" || resulttype3=="Good" || resulttype4S=="Good"  || resulttype8=="Good" ,1,0];
resultC=If[resulttype4MS=="Good"&&uentropyms>0&&complexentropyms==False||resulttype3=="Good"&&uenergy>0&&complexenergy==False||resulttype4S=="Good"&&uentropy>0&&complexentropy==False||resulttype8=="Good"&&uenergym>0&&complexenergym==False,1,0];

If[resultA==1,MyPrint["AllBad"];];
If[resultA==0,MyPrint["NotAllBad"];];
If[resultB==1,MyPrint["OneGood"];];
If[resultB==0,MyPrint["NotOneGood"];];
If[resultC==1,MyPrint["OneActualGood"];];
If[resultC==0,MyPrint["NotOneActualGood"];];




(* OTHERS *)
If[0,
(* no-evolve M1 *)
dtcold=0;
ferr0=rhou[[1]]-rho0;
ferr1=Table[(Rud[[1,ii]]-Rud0[[ii]])+dtcold*Gd[[ii]],{ii,1,4}];
ferr2=Table[(Tud[[1,ii]]-Tud0[[ii]])-dtcold*Gd[[ii]],{ii,1,4}];
eqns={ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[2]]==0,ferr2[[3]]==0,ferr2[[4]]==0};
Print["2FindRoot"];
result=FindRoot[eqns,{{rho,rhoi},{u,ui},{uu1,uu1i},{uu2,uu2i},{uu3,uu3i},{Er,Eri},{uru1,uru1i},{uru2,uru2i},{uru3,uru3i}},WorkingPrecision->Wwprec,MaxIterations->10000,AccuracyGoal->Wtolprec,PrecisionGoal->Wtolprec, Jacobian->JacobianType];
Print["2result=",result];
Print["2ferr0=",(ferr0/rhoi)//.result];
Print["2ferr1=",(ferr1/Max[ui,Eri])//.result];
Print["2ferr2=",(ferr2/Max[ui,Eri])//.result];


(* COLD M1 *)
ferr0=rhou[[1]]-rho0;
ferr1=Table[(Rud[[1,ii]]-Rud0[[ii]])+dtcold*Gd[[ii]],{ii,1,4}];
ferr2=Table[(Tud[[1,ii]]-Tud0[[ii]])-dtcold*Gd[[ii]],{ii,1,4}];
eqns={ferr0==0,ferr1[[1]]==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[3]]==0,ferr2[[4]]==0}//.{u->0};
Print["2FindRoot"];
result=FindRoot[eqns,{{rho,rhoi},{uu1,uu1i},{uu2,uu2i},{uu3,uu3i},{Er,Eri},{uru1,uru1i},{uru2,uru2i},{uru3,uru3i}},WorkingPrecision->Wwprec,MaxIterations->10000,AccuracyGoal->Wtolprec,PrecisionGoal->Wtolprec, Jacobian->JacobianType];
Print["2result=",result];
Print["2ferr0=",(ferr0/rhoi)//.result];
Print["2ferr1=",(ferr1/Max[ui,Eri])//.result];
Print["2ferr2=",(ferr2/Max[ui,Eri])//.result];

(* COLD COLD M1 *)
dtcold=0;
ferr0=rhou[[1]]-rho0;
ferr1=Table[(Rud[[1,ii]]-Rud0[[ii]])+dtcold*Gd[[ii]],{ii,1,4}];
ferr2=Table[(Tud[[1,ii]]-Tud0[[ii]])-dtcold*Gd[[ii]],{ii,1,4}];
eqns={ferr0==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[3]]==0,ferr2[[4]]==0}//.{u->0,Er->10^(-10)};
Print["3FindRoot"];
result=FindRoot[eqns,{{rho,rhoi},{uu1,uu1i},{uu2,uu2i},{uu3,uu3i},{uru1,uru1i},{uru2,uru2i},{uru3,uru3i}},WorkingPrecision->Wwprec,MaxIterations->10000,AccuracyGoal->Wtolprec,PrecisionGoal->Wtolprec, Jacobian->JacobianType];
Print["3result=",result];
Print["3ferr0=",(ferr0/rhoi)//.result];
Print["3ferr1=",(ferr1/Max[ui,Eri])//.result];
Print["3ferr2=",(ferr2/Max[ui,Eri])//.result];

(* COLD COLD  LIKE CODE M1*)
gammamax=1000;
mysolsuru1=Solve[uru0==gammamax,uru1];
mysolsuru1//.consts;
choosesolsuru1=mysolsuru1[[2,1,2]];
mysolsuru1;
ferr0=rhou[[1]]-rho0;
ferr1=Table[(Rud[[1,ii]]-Rud0[[ii]])+dtcold*Gd[[ii]],{ii,1,4}];
ferr1[[1]]=choosesolsuru1==uru1;
ferr2=Table[(Tud[[1,ii]]-Tud0[[ii]])-dtcold*Gd[[ii]],{ii,1,4}];
eqns={ferr0==0,ferr1[[2]]==0,ferr1[[3]]==0,ferr1[[4]]==0,ferr2[[1]]==0,ferr2[[3]]==0,ferr2[[4]]==0}//.{u->0,Er->10^(-10)};
Print["4FindRoot"];
result=FindRoot[eqns,{{rho,rhoi},{uu1,uu1i},{uu2,uu2i},{uu3,uu3i},{uru1,uru1i},{uru2,uru2i},{uru3,uru3i}},WorkingPrecision->Wwprec,MaxIterations->10000,AccuracyGoal->Wtolprec,PrecisionGoal->Wtolprec, Jacobian->JacobianType];
Print["4result=",result];
Print["4ferr0=",(ferr0/rhoi)//.result];
Print["4ferr1=",(ferr1/Max[ui,Eri])//.result];
Print["4ferr2=",(ferr2/Max[ui,Eri])//.result];
];
];
















